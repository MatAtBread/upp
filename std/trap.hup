#ifndef __UPP_STDLIB_TRAP_H__
#define __UPP_STDLIB_TRAP_H__

@define trap(arg) {
    const declNode = upp.consume(['declaration', 'field_declaration'], 'expected a variable or field declaration');

    // Find the primary identifier being declared (handles normal vars and struct fields)
    const isId = n => n.type === 'identifier' || n.type === 'field_identifier';
    const varIdNode = declNode.find(n => {
        if (!isId(n)) return false;
        let p = n;
        while (p && p !== declNode) {
            if (p.fieldName === 'declarator' || p.fieldName === 'field' || p.type === 'init_declarator') {
                 // Ensure we aren't in the 'value' side of an init_declarator
                 if (p.type === 'init_declarator' && n.parent === p && n.fieldName === 'value') return false;
                 return true;
            }
            p = p.parent;
        }
        return false;
    })[0] || declNode.find(isId)[0];

    if (!varIdNode) {
        upp.error(declNode, `Could not find declared identifier in ${declNode.type} for @trap`);
    }

    const varName = varIdNode.text;
    let handlerName = "";

    // Determine Handler Name
    const trimmedArg = arg.trim();
    if (trimmedArg.startsWith('{')) {
        const typeStr = upp.getType(varIdNode);
        handlerName = upp.createUniqueIdentifier(`${varName}_trap`);
        upp.hoist(`${typeStr} ${handlerName}(${typeStr} value) ${trimmedArg}\n`);
    } else if (/^[a-zA-Z_]\w*$/.test(trimmedArg)) {
        handlerName = trimmedArg;
    } else {
        upp.error(declNode, `@trap argument '${trimmedArg}' must be a code block or function identifier`);
    }

    const processed = new WeakSet();

    // Transform assignments using scope-aware withReferences (for variables)
    // and pattern-based matching (for struct fields until UPP has full member resolution)
    if (declNode.type === 'field_declaration') {
        upp.withPattern('assignment_expression', (node, helpers) => {
            const left = node.named['left'];
            if (left && left.type === 'field_expression') {
                const field = left.named['field'];
                return field && field.text === varName;
            }
            return false;
        }, (node, helpers) => {
            const expr = node.named['right'];
            if (expr && !processed.has(expr)) {
                expr.insertBefore(`${handlerName}(`);
                expr.insertAfter(`)`);
                processed.add(expr);
            }
        });
    } else {
        upp.withReferences(declNode, (refNode, helpers) => {
            // Find the top-level expression targeting this reference
            let current = refNode;
            while (current.parent && (current.parent.type === 'field_expression')) {
                current = current.parent;
            }

            const parent = current.parent;
            if (parent && parent.type === 'assignment_expression' && parent.named['left'] === current) {
                const expr = parent.named['right'];
                if (expr && !processed.has(expr)) {
                    expr.insertBefore(`${handlerName}(`);
                    expr.insertAfter(`)`);
                    processed.add(expr);
                }
            }
        });
    }

    // Handle initial value in declaration
    if (declNode.type === 'declaration') {
        const initDecl = declNode.named['declarator']; // init_declarator
        if (initDecl && initDecl.type === 'init_declarator') {
            const val = initDecl.named['value'];
            if (val && !processed.has(val)) {
                val.insertBefore(`${handlerName}(`);
                val.insertAfter(`)`);
                processed.add(val);
            }
        }
    }

    return declNode;
}


#endif