#ifndef __UPP_STDLIB_FIELDSOF_H__
#define __UPP_STDLIB_FIELDSOF_H__

@define fieldsof(targetStruct) {
    // 1. Validate Context
    // We expect the macro to be inside a struct definition, i.e., parent should be field_declaration_list
    const ctx = upp.findEnclosing(upp.contextNode, 'field_declaration_list');

    if (!ctx) {
        upp.error(upp.invocation.invocationNode, "@fieldsof must be used inside a struct definition");
    }

    // 1b. Consume Trailing Semicolon
    // If the user wrote @fieldsof(...); we want to eat that semicolon so we don't end up with ;;
    const inv = upp.invocation;
    const source = upp.context.tree.source;
    let end = inv.endIndex;

    // Skip whitespace
    while (end < source.length && /\s/.test(source[end])) {
        end++;
    }

    if (source[end] === ';') {
        inv.endIndex = end + 1;
    }

    // 2. Resolve Target Type
    // targetStruct is like "struct Base", "Base", or "GeoCoord"
    let targetName = targetStruct.trim();
    let options = { variable: true, tag: true };

    if (targetName.startsWith('struct ')) {
        targetName = targetName.substring(7).trim();
        options = { variable: false, tag: true };
    }

    const def = upp.findDefinition(targetName, options);
    let structDef = null;

    if (def) {
        if (def.type === 'struct_specifier') {
            structDef = def;
        } else {
             const actualDef = def.parent && def.parent.type === 'type_definition' ? def.parent : def;
             const matches = actualDef.find('struct_specifier');
             if (matches.length > 0) {
                 structDef = matches[0];
             }
        }
    }

    if (!structDef) {
        upp.error(upp.invocation.invocationNode, `Could not find definition for struct/type ${targetName}`);
        return;
    }

    let fieldList = structDef.named['body'];
    if (!fieldList) {
        // Fallback: search for field_declaration_list among children
        for (let i = 0; i < structDef.childCount; i++) {
            const c = structDef.child(i);
            if (c.type === 'field_declaration_list') {
                fieldList = c;
                break;
            }
        }
    }

    if (!fieldList) {
        return "";
    }

    let fields = "";
    for (let i = 0; i < fieldList.childCount; i++) {
        const child = fieldList.child(i);
        if (child.type === 'field_declaration') {
            fields += child.text + "\n    ";
        }
    }

    return fields;
}

#endif
