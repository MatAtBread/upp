#ifndef __UPP_STDLIB_FIELDSOF_H__
#define __UPP_STDLIB_FIELDSOF_H__

@define fieldsof(targetStruct) {
    // 1. Validate Context
    // We expect the macro to be inside a struct definition, i.e., parent should be field_declaration_list
    const ctx = upp.findEnclosing(upp.contextNode, 'field_declaration_list');

    if (!ctx) {
        upp.error(upp.invocation.invocationNode, "@fieldsof must be used inside a struct definition");
    }

    // 1b. Consume Trailing Semicolon
    // If the user wrote @fieldsof(...); we want to eat that semicolon so we don't end up with ;;
    const inv = upp.invocation;
    const source = upp.registry.sourceCode;
    let end = inv.endIndex;

    // Skip whitespace
    while (end < source.length && /\s/.test(source[end])) {
        end++;
    }

    if (source[end] === ';') {
        inv.endIndex = end + 1;
    }

    // 2. Resolve Target Type
    // targetStruct is like "struct Base", "Base", or "GeoCoord"
    let targetName = targetStruct.trim();
    let isStructTag = false;
    if (targetName.startsWith('struct ')) {
        targetName = targetName.substring(7).trim();
        isStructTag = true;
    }

    let structDef = null;
    const root = upp.root;

    upp.walk(root, (node) => {
        if (structDef) return;

        const isTypedef = node.type === 'type_definition' || (node.type === 'declaration' && node.text.includes('typedef'));

        // Option A: struct Tag { ... }
        if (node.type === 'struct_specifier') {
             const nameNode = upp.childForFieldName(node, 'name');
             if (isStructTag && nameNode && nameNode.text === targetName) {
                 if (upp.childForFieldName(node, 'body')) structDef = node;
             }
             else if (!isStructTag && nameNode && nameNode.text === targetName) {
                 if (upp.childForFieldName(node, 'body')) structDef = node;
             }
        }

        // Option B/C: typedef struct { ... } Name;
        if (!isStructTag && isTypedef) {
             const typeNode = upp.childForFieldName(node, 'type');
             if (typeNode && typeNode.type === 'struct_specifier') {
                 const idMatches = upp.query('(type_identifier) @id', node);
                 for (const match of idMatches) {
                     if (match.captures.id.text === targetName) {
                         structDef = typeNode;
                         break;
                     }
                 }
             }
        }
    });

    if (!structDef) {
        upp.error(upp.invocation.invocationNode, `Could not find definition for struct/type ${targetName}`);
        return;
    }

    const fieldList = upp.childForFieldName(structDef, 'body');
    if (!fieldList) {
        return "";
    }

    let fields = "";
    for (let i = 0; i < upp.childCount(fieldList); i++) {
        const child = upp.child(fieldList, i);
        if (child.type === 'field_declaration') {
            fields += child.text + "\n    ";
        }
    }

    return fields;
}

#endif
