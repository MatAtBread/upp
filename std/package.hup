@define implements(pkgName) {
    // Marker macro used by @package
}

@define package(pkgName) {
    if (!upp.parentHelpers) {
        // This macro is intended to be run from an included file (like pkg.hup)
        // inspecting the parent (like pkg.cup).
        return "";
    }

    const nameSpace = pkgName + "_";
    const publicProtos = [];

    // 1. Check if the parent file explicitly implements this package
    const impls = upp.parentHelpers.findInvocations('implements');
    const isImpl = impls.some(inv => inv.text.includes(pkgName));

    if (isImpl) {
        upp.registry.shouldMaterializeDependency = true;
        if (upp.parentHelpers && upp.parentHelpers.registry) {
            upp.parentHelpers.registry.shouldMaterializeDependency = true;
        }

        // Find public functions to generate headers
        const functions = upp.parentHelpers.query('function_definition');
        for (const { node: fn } of functions) {
            let isStatic = false;
            for (const child of fn.children) {
                if (child.type === 'storage_class_specifier' && child.text === 'static') {
                    isStatic = true;
                    break;
                }
            }

            if (!isStatic) {
                const { returnType, name, params } = upp.parentHelpers.getFunctionSignature(fn);
                if (name !== 'unknown' && !name.startsWith(nameSpace)) {
                    publicProtos.push(`extern ${returnType} ${nameSpace}${name}${params};`);
                }
            }
        }

        // Register transformation rule for the parent context
        upp.registerTransformRule({
            id: `package_${pkgName}_renamer`,
            type: 'pattern',
            active: true,
            matcher: (node, helpers) => {
                if (node.type === 'function_definition') {
                    const sig = helpers.getFunctionSignature(node);
                    let isStatic = false;
                    for (const child of node.children) {
                        if (child.type === 'storage_class_specifier' && child.text === 'static') {
                            isStatic = true;
                            break;
                        }
                    }
                    if (isStatic) return false;
                    return sig.name !== 'unknown' && !sig.name.startsWith(nameSpace);
                }

                if (node.type === 'call_expression') {
                    const funcNode = node.findChildByFieldName('function');
                    if (!funcNode || funcNode.text.startsWith(nameSpace)) return false;

                    const name = funcNode.text;
                    const allFns = helpers.query('function_definition');
                    const def = allFns.find(f => {
                        const sig = helpers.getFunctionSignature(f.node);
                        return sig.name === name || sig.name === nameSpace + name;
                    });
                    
                    if (def) {
                        let fnNode = def.node;
                        let isStatic = false;
                        for (const child of fnNode.children) {
                             if (child.type === 'storage_class_specifier' && child.text === 'static') {
                                 isStatic = true;
                                 break;
                             }
                        }
                        return !isStatic;
                    }
                }
                return false;
            },
            callback: (node, helpers) => {
                if (node.type === 'function_definition') {
                    const { name, nameNode } = helpers.getFunctionSignature(node);
                    if (nameNode) nameNode.text = nameSpace + name;
                    return undefined;
                }
                if (node.type === 'call_expression') {
                    const funcNode = node.findChildByFieldName('function');
                    funcNode.text = nameSpace + funcNode.text;
                    return undefined;
                }
            }
        });
    }

    const stdDir = upp.stdPath || "";
    const parentDir = upp.path.dirname(upp.registry.originPath || "");
    let packageHPath = "package.h";
    if (stdDir && parentDir) {
        packageHPath = upp.path.relative(parentDir, upp.path.join(stdDir, 'package.h'));
    }

    return `#include "${packageHPath}"\n` + publicProtos.join('\n');
}
