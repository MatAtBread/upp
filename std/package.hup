@define implements(pkgName) {
    // Marker macro used by @package
}

@define package(pkgName) {
    if (!upp.parentHelpers) {
        // This macro is intended to be run from an included file (like pkg.hup)
        // inspecting the parent (like pkg.cup).
        return "";
    }

    const nameSpace = pkgName + "_";
    const publicProtos = [];

    // 1. Check if the parent file explicitly implements this package
    const isImpl = upp.parentHelpers.findInvocations('implements').some(inv => inv.text.includes(pkgName));

    if (isImpl) {
        upp.registry.shouldMaterializeDependency = true;
        if (upp.parentHelpers.registry) {
            upp.parentHelpers.registry.shouldMaterializeDependency = true;
        }

        // Find public functions to generate headers
        const functions = upp.parentHelpers.root.find('function_definition');
        for (const fn of functions) {
            const isStatic = fn.children.some(c => c.type === 'storage_class_specifier' && c.text === 'static');
            if (isStatic) continue;

            const { returnType, name, params, nameNode } = upp.parentHelpers.getFunctionSignature(fn);
            if (name !== 'unknown' && !name.startsWith(nameSpace)) {
                publicProtos.push(`extern ${returnType} ${nameSpace}${name}${params};`);
                
                const originalName = name;
                
                // Immediately rename all existing references in the tree
                const refs = upp.parentHelpers.findReferences(nameNode);
                for (const ref of refs) {
                    ref.text = nameSpace + originalName;
                }

                // Register a rule via withPattern for any future references (like from other macros)
                // We use withPattern instead of withReferences because findDefinition 
                // will fail to resolve 'add' to 'mypkg_add' once renamed.
                upp.parentHelpers.withPattern('identifier',
                    (node, h) => node.text === originalName,
                    (node, h) => nameSpace + originalName
                );

                // Rename definition
                nameNode.text = nameSpace + originalName;
            }
        }
    }

    return publicProtos.join('\n');
}
