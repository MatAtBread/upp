@define implements(pkgName) {
}

@define package(pkgName) {
    if (!upp.parentTree) {
        // This macro is intended to be run from an included file (like pkg.hup)
        // inspecting the parent (like pkg.cup).
        console.warn("@package used without a parent context (should be used inside an @included file)");
        return;
    }

    const nameSpace = pkgName + "_";
    const publicProtos = [];

    // 1. Check if the parent file explicitly implements this package
    const parentInvocations = upp.parentRegistry.invocations;
    const parentSource = upp.parentRegistry.sourceCode;
    const isImpl = parentInvocations.some(inv =>
        (inv.name === 'implements' || inv.name === 'implement') && inv.args[0] === pkgName
    ) || new RegExp(`^\\s*@(?:implements|implement)\\s*\\(\\s*${pkgName}\\s*\\)`, 'm').test(parentSource);

    const root = upp.parentTree;

    if (isImpl) {
        upp.registry.shouldMaterializeDependency = true;
        const definitions = upp.parentRegistry.helpers.query('(function_definition) @fn', root);

        for (const match of definitions) {
            const fn = match.captures.fn;

            let isStatic = false;
            for(let i=0; i<fn.childCount; i++) {
                 const child = fn.child(i);
                 if (child.type === 'storage_class_specifier' && child.text === 'static') {
                     isStatic = true;
                     break;
                 }
            }

            const { returnType, name, params } = upp.parentRegistry.helpers.getFunctionSignature(fn);
            if (name === "unknown" || name.startsWith(nameSpace)) continue;

            if (!isStatic) {
                publicProtos.push(`${returnType} ${nameSpace}${name}${params};`);
            }
        }
    }

    // 3. Registering Transform for the Parent (only if IMPLEMENTING)
    if (isImpl) {
        upp.registerParentTransform((_root, pHelpers) => {
             // Rename local calls FIRST (while definitions still have old names)
             pHelpers.matchReplaceAll(_root, '$call__call_expression', ({call}) => {
                 const funcNode = pHelpers.childForFieldName(call, 'function');
                 if (!funcNode) return null;
                 const funcName = funcNode.text;

                 const def = pHelpers.getDefinition(funcNode);
                 if (def && pHelpers.isDescendant(_root, def)) {
                     let fnDef = def;
                     while(fnDef && fnDef.type !== 'function_definition' && fnDef.parent) fnDef = fnDef.parent;

                     if (fnDef && fnDef.type === 'function_definition') {
                         let isStaticVal = false;
                         try {
                              for(let i=0; i<fnDef.childCount; i++) {
                                 const child = fnDef.child(i);
                                 if (child.type === 'storage_class_specifier' && child.text === 'static') {
                                     isStaticVal = true;
                                     break;
                                 }
                             }
                         } catch (e) {}

                         if (!isStaticVal && !funcName.startsWith(nameSpace)) {
                             const args = pHelpers.childForFieldName(call, 'arguments');
                             return pHelpers.code`${nameSpace}${funcName}${args}`;
                         }
                     }
                 }
             });

             // Rename definitions AFTER calls
             pHelpers.matchReplaceAll(_root, '$fn__function_definition', ({fn}) => {
                 let isStatic = false;
                 try {
                     for(let i=0; i<fn.childCount; i++) {
                         const child = fn.child(i);
                         if (child.type === 'storage_class_specifier' && child.text === 'static') {
                             isStatic = true;
                             break;
                         }
                     }
                 } catch (e) {}

                 if (isStatic) return;

                 const { name, nameNode } = pHelpers.getFunctionSignature(fn);
                 if (name === "unknown" || name.startsWith(nameSpace)) return;

                 if (nameNode) {
                    pHelpers.replace(nameNode, nameSpace + name);
                 }
             });
        });
    }

    return publicProtos.join('\n');
}
