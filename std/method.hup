#ifndef __UPP_STDLIB_METHOD_H__
#define __UPP_STDLIB_METHOD_H__

@define method(targetType) {
    const node = upp.consume(['function_definition', 'declaration']);
    if (!node) return "";

    const funcDeclarator = upp.childForFieldName(node, 'declarator');

    // Handle pointer declarators
    let funcDecl = funcDeclarator;
    while (funcDecl && funcDecl.type === 'pointer_declarator') {
        funcDecl = upp.childForFieldName(funcDecl, 'declarator');
    }

    const funcIdentifier = upp.childForFieldName(funcDecl, 'declarator');
    if (!funcIdentifier) return node.text;

    const originalName = funcIdentifier.text;

    // Prevent infinite recursion
    if (originalName.startsWith('_') && originalName.includes('_method_')) {
        return node.text;
    }

    // Clean target type (remove 'struct ' prefix if present)
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }

    // Generate new name: _Point_method_getX
    const newName = `_${cleanTarget}_method_${originalName}`;

    // Rename the function
    let functionText = node.text;
    const idStart = funcIdentifier.startIndex - node.startIndex;
    const idEnd = funcIdentifier.endIndex - node.startIndex;
    functionText = functionText.slice(0, idStart) + newName + functionText.slice(idEnd);

    // Use withPattern to transform method calls
    const marker = upp.withPattern('call_expression',
        (callNode, helpers) => {
            // Check if this is a field_expression call (obj.method() or obj->method())
            const funcNode = callNode.childForFieldName('function');
            if (!funcNode || funcNode.type !== 'field_expression') return false;

            const objectNode = funcNode.childForFieldName('argument');
            const methodNode = funcNode.childForFieldName('field');

            // Check if method name matches
            if (!objectNode || !methodNode || methodNode.text !== originalName) return false;

            // Get the object's type
            const objDef = helpers.getDefinition(objectNode);
            if (!objDef) return false;

            let objType = helpers.getType(objDef);
            let cleanObjType = objType.replace(/\*/g, '').replace(/struct /g, '').trim();

            // Check if type matches (direct or via typedef)
            if (cleanObjType === cleanTarget) {
                return true;
            }

            // Try to resolve typedef
            let foundTypedef = false;
            helpers.walk(helpers.root, (n) => {
                if (n.type === 'type_definition') {
                    const typeNode = n.childForFieldName('type');
                    const declaratorNode = n.childForFieldName('declarator');
                    if (typeNode && declaratorNode) {
                        const underlyingType = typeNode.text.replace(/struct /g, '').trim();
                        const typedefName = declaratorNode.text.trim();
                        if (typedefName === cleanObjType && underlyingType === cleanTarget) {
                            foundTypedef = true;
                        }
                    }
                }
            });

            return foundTypedef;
        },
        (callNode) => {
            console.log(`[method] TRANSFORMING: ${callNode.text.substring(0, 40)}`);
            // Transform: obj.method(args) -> _Type_method_method(&obj, args)
            const funcNode = callNode.childForFieldName('function');
            const objectNode = funcNode.childForFieldName('argument');
            const argsNode = callNode.childForFieldName('arguments');

            let argsText = '';
            if (argsNode && argsNode.namedChildCount > 0) {
                const argsInner = argsNode.text.slice(1, -1).trim();
                argsText = argsInner ? `, ${argsInner}` : '';
            }

            // Get operator (. or ->)
            const opNode = funcNode.child(1);
            const operator = opNode ? opNode.text : '.';

            const addrPrefix = operator === '.' ? '&' : '';
            return `${newName}(${addrPrefix}${objectNode.text}${argsText})`;
        }
    );

    // Return the renamed function + marker
    return functionText + ' ' + marker;
}

#endif
