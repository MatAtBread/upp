@define method(targetType) {
    let node = upp.nextNode(['function_definition', 'declaration']);
    if (!node) {
        node = upp.findEnclosing(upp.contextNode, ['function_definition', 'declaration']);
    }
    if (!node) return "";

    const sig = upp.getFunctionSignature(node);
    if (!sig.nameNode) return node.text;

    const originalName = sig.name;
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }

    // Generate new name: _Point_method_getX
    const newName = `_${cleanTarget}_method_${originalName}`;

    // Rename the function identifier stable-y
    sig.nameNode.text = newName;

    // Use withPattern to transform method calls
    upp.withPattern('call_expression',
        (callNode, helpers) => {
            // Check if this is a field_expression call (obj.method() or obj->method())
            const funcNode = helpers.childForFieldName(callNode, 'function');
            if (!funcNode || funcNode.type !== 'field_expression') return false;

            const objectNode = helpers.childForFieldName(funcNode, 'argument');
            const methodNode = helpers.childForFieldName(funcNode, 'field');

            if (!objectNode || !methodNode) return false;
            if (methodNode.text !== originalName) return false;

            const objDef = helpers.findDefinitionOrNull(objectNode);
            if (!objDef) return false;

            let objType = helpers.getType(objDef);
            let cleanObjType = objType.replace(/\*/g, '').replace(/struct /g, '').trim();

            if (cleanObjType === cleanTarget) return true;

            // Try to resolve typedef
            const typeDef = helpers.findDefinition(cleanObjType);
            if (typeDef && typeDef.type === 'type_definition') {
                 const typeNode = typeDef.children.find(c => 
                    c.type !== 'type_identifier' && 
                    c.type !== 'storage_class_specifier' && 
                    c.text !== 'typedef' && 
                    c.type !== ';'
                 );
                 
                 if (typeNode) {
                     let resolvedType = typeNode.text;
                     let cleanResolved = resolvedType.replace(/\*/g, '').replace(/struct /g, '').trim();
                     return cleanResolved === cleanTarget;
                 }
            }
            return false;
        },
        (callNode, helpers) => {
            const funcNode = helpers.childForFieldName(callNode, 'function');
            const targetNode = helpers.childForFieldName(funcNode, 'argument');
            const argsNode = helpers.childForFieldName(callNode, 'arguments');

            // Transform f.print() into _Foo_method_print(&f)
            let argsText = argsNode ? argsNode.text : "()";
            const separator = (argsText === "()") ? "" : ", ";
            const innerArgs = (argsText === "()") ? "" : argsText.slice(1, -1);
            
            const objDef = helpers.findDefinitionOrNull(targetNode);
            const objType = objDef ? helpers.getType(objDef) : "";
            const isPointer = objType.includes('*');
            const prefix = isPointer ? "" : "&";

            return `${newName}(${prefix}${targetNode.text}${separator}${innerArgs})`;
        }
    );

    return null; // Node already updated in-place
}
