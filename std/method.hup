@define method(targetType) {
    const node = upp.nextNode(['function_definition', 'declaration']);
    if (!node) return "";

    const sig = upp.getFunctionSignature(node);
    if (!sig.nameNode) return node.text;

    const originalName = sig.name;
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }

    // Generate new name: _Point_method_getX
    const newName = `_${cleanTarget}_method_${originalName}`;

    // Rename the function identifier stable-y
    sig.nameNode.text = newName;

    // Use withPattern to transform method calls
    upp.withPattern('call_expression',
        (callNode, helpers) => {
            // Check if this is a field_expression call (obj.method() or obj->method())
            const funcNode = helpers.childForFieldName(callNode, 'function');
            if (!funcNode || funcNode.type !== 'field_expression') return false;

            const objectNode = helpers.childForFieldName(funcNode, 'argument');
            const methodNode = helpers.childForFieldName(funcNode, 'field');

            if (!objectNode || !methodNode) return false;
            if (methodNode.text !== originalName) return false;

            const objDef = helpers.findDefinition(objectNode);
            if (!objDef) return false;

            let objType = helpers.getType(objDef);
            let cleanObjType = objType.replace(/\*/g, '').replace(/struct /g, '').trim();

            return cleanObjType === cleanTarget;
        },
        (callNode, helpers) => {
            const funcNode = helpers.childForFieldName(callNode, 'function');
            const targetNode = helpers.childForFieldName(funcNode, 'argument');
            const argsNode = helpers.childForFieldName(callNode, 'arguments');

            // Transform f.print() into _Foo_method_print(&f)
            let argsText = argsNode ? argsNode.text : "()";
            const separator = (argsText === "()") ? "" : ", ";
            const innerArgs = (argsText === "()") ? "" : argsText.slice(1, -1);
            
            return `${newName}(&${targetNode.text}${separator}${innerArgs})`;
        }
    );

    return null; // Node already updated in-place
}
