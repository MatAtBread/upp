@define method(targetType) {
    const node = upp.consume(['function_definition', 'declaration']);
    if (!node) return "";
    console.log(`[method] Consumed node: ${node.type} text="${node.text.slice(0, 40)}"`);

    const funcDeclarator = upp.childForFieldName(node, 'declarator');
    console.log(`[method] funcDeclarator: ${funcDeclarator ? funcDeclarator.type : 'null'} text="${funcDeclarator ? funcDeclarator.text : ''}" range=[${funcDeclarator ? funcDeclarator.startIndex : 0}, ${funcDeclarator ? funcDeclarator.endIndex : 0}]`);

    // Handle pointer declarators
    let funcDecl = funcDeclarator;
    while (funcDecl && funcDecl.type === 'pointer_declarator') {
        funcDecl = upp.childForFieldName(funcDecl, 'declarator');
    }

    const funcIdentifier = upp.childForFieldName(funcDecl, 'declarator');
    console.log(`[method] funcIdentifier: ${funcIdentifier ? funcIdentifier.type : 'null'} text="${funcIdentifier ? funcIdentifier.text : ''}"`);
    if (!funcIdentifier) return node.text;

    const originalName = funcIdentifier.text;
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }

    // Generate new name: _Point_method_getX
    const newName = `_${cleanTarget}_method_${originalName}`;

    const idStart = funcIdentifier.startIndex - node.startIndex;
    const idEnd = funcIdentifier.endIndex - node.startIndex;

    // Rename the function
    let functionText = node.text;
    functionText = functionText.slice(0, idStart) + newName + functionText.slice(idEnd);

    // Strip the macro invocation itself from the text to avoid double-comments or recursive expansion
    functionText = functionText.replace(/\/\*@method\([^)]*\)\*\//g, '');

    // Use withPattern to transform method calls
    const marker = upp.withPattern('call_expression',
        (callNode, helpers) => {
            // Check if this is a field_expression call (obj.method() or obj->method())
            const funcNode = helpers.childForFieldName(callNode, 'function');
            if (!funcNode || funcNode.type !== 'field_expression') return false;

            const objectNode = helpers.childForFieldName(funcNode, 'argument');
            const methodNode = helpers.childForFieldName(funcNode, 'field');

            // Check if method name matches
            if (!objectNode || !methodNode) return false;

            console.log(`[method.hup matcher] checking call: ${objectNode.text}.${methodNode.text}`);
            if (methodNode.text !== originalName) return false;

            // Get the object's type
            const objDef = helpers.getDefinition(objectNode);
            console.log(`[method.hup matcher] objDef: ${objDef ? objDef.type : 'null'} text="${objDef ? objDef.text : ''}"`);
            if (!objDef) return false;

            let objType = helpers.getType(objDef);
            console.log(`[method.hup matcher] objType: ${objType}`);
            let cleanObjType = objType.replace(/\*/g, '').replace(/struct /g, '').trim();

            // Check if type matches (direct or via typedef)
            if (cleanObjType === cleanTarget) {
                console.log(`[method.hup matcher] MATCH!`);
                return true;
            }
            return false;
        },
        (callNode, helpers) => {
            const funcNode = helpers.childForFieldName(callNode, 'function');
            const targetNode = helpers.childForFieldName(funcNode, 'argument');
            const argsNode = helpers.childForFieldName(callNode, 'arguments');

            // Transform f.print() into _Foo_method_print(&f)
            let argsText = argsNode ? argsNode.text : "()";
            if (argsText === "()") {
                argsText = `(&${targetNode.text})`;
            } else {
                argsText = `(&${targetNode.text}, ${argsText.slice(1)}`;
            }

            return `${newName}${argsText}`;
        }
    );

    return functionText;
}
