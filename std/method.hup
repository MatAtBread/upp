#ifndef __UPP_STDLIB_METHOD_H__
#define __UPP_STDLIB_METHOD_H__

@define method(targetType) {
    const node = upp.consume(['function_definition', 'declaration']);
    // Re-parse for stability (workaround for tree-sitter instability)
    let funcDef = node;
    try {
        if (upp.parseFragment) {
            const freshRoot = upp.parseFragment(node.text);
            if (freshRoot && freshRoot.childCount > 0) {
                funcDef = freshRoot.child(0);
            }
        }
    } catch (e) {}


    let isExternDecl = (node.type === 'declaration');

    const funcDeclarator = upp.childForFieldName(funcDef, 'declarator');

    // Handle potential pointer declarators
    let funcDecl = funcDeclarator;
    while (funcDecl && funcDecl.type === 'pointer_declarator') {
        funcDecl = upp.childForFieldName(funcDecl, 'declarator');
    }

    const funcIdentifier = upp.childForFieldName(funcDecl, 'declarator');
    if (!funcIdentifier) return;

    const originalName = funcIdentifier.text;

    // Check for infinite loop / recursion
    if (originalName.startsWith('_') && originalName.includes('_method_')) {
         return isExternDecl ? node.text : node.text;
    }

    // 1. Sanitize targetType to handle "struct Point" vs "Point"
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }

    // 2. Generate new name: _Point_method_distance
    const newName = `_${cleanTarget}_method_${originalName}`;

    let outputText = "";

    // 3. Rename
    if (isExternDecl) {
        // Transform the DECLARATOR only (disjoint from macro).
        // Return the consumed type node text (to restore the hole we made).
        let declaratorText = funcDeclarator.text;
        const startOffset = funcIdentifier.startIndex - funcDeclarator.startIndex;
        const endOffset = funcIdentifier.endIndex - funcDeclarator.startIndex;
        const newDeclaratorText = declaratorText.slice(0, startOffset) + newName + declaratorText.slice(endOffset);

        upp.replace(funcDeclarator, newDeclaratorText);
        outputText = node.text;
    } else {
        // Standard Definition Renaming
        let functionText = node.text;
        const idStart = (funcIdentifier.tree === node.tree) ? (funcIdentifier.startIndex - node.startIndex) : funcIdentifier.startIndex;
        const idEnd = (funcIdentifier.tree === node.tree) ? (funcIdentifier.endIndex - node.startIndex) : funcIdentifier.endIndex;
        functionText = functionText.slice(0, idStart) + newName + functionText.slice(idEnd);
        outputText = functionText;
    }

    // 4. Register global transformer for method calls
    upp.registerTransform((root, helpers) => {
        const transformCall = (callNode, objectNode, argsNode, operator) => {
            // CHECK FOR CONFLICTS
            const isConflict = helpers.registry.helpers.replacements.some(r => {
                return (r.start < callNode.endIndex && r.end > callNode.startIndex);
            });
            if (isConflict) return null;

            // Type Validation
            const objDef = helpers.getDefinition(objectNode);
            if (objDef) {
                let objType = helpers.getType(objDef);

                // FALLBACK FOR VOID/BROKEN TYPES
                if (objType.includes('void')) {
                    const varName = objectNode.text;
                    try {
                        const decls = helpers.query(`(declaration type: (_) @type declarator: [(identifier) @id (init_declarator declarator: (identifier) @id)])`, root);
                        for (const d of decls) {
                             if (d.captures.id.text === varName) {
                                 objType = d.captures.type.text;
                                 break;
                             }
                        }
                    } catch (e) {}
                }

                let cleanObjType = objType.replace(/\*/g, '').replace(/struct /g, '').trim();
                let targetAlias = cleanTarget;

                if (cleanObjType !== cleanTarget) {
                    try {
                        const typedefs = helpers.query(`(type_definition type: (_) @type declarator: (type_identifier) @name)`, root);
                        for (const t of typedefs) {
                             const nameText = t.captures.name.text;
                             const typeText = t.captures.type.text.replace(/struct /g, '').trim();
                             if (nameText === cleanTarget) targetAlias = typeText;
                             if (nameText === cleanObjType) cleanObjType = typeText;
                        }
                    } catch(e) {}
                }

                if (cleanObjType !== cleanTarget && cleanObjType !== targetAlias) return null;
            } else {
                 return null;
            }

            const objRef = operator === '.' ? `&(${objectNode.text})` : objectNode.text;
            const argsText = argsNode.text.slice(1, -1);
            const finalArgs = objRef + (argsText.trim() ? ', ' + argsText : '');
            return helpers.code`${newName}(${finalArgs})`;
        };

        const calls = helpers.query(`
            (call_expression) @call
        `, root);

        for (const m of calls) {
            const callNode = m.captures.call;
            const funcNode = callNode.childForFieldName('function');

            if (!funcNode || funcNode.type !== 'field_expression') continue;

            const objectNode = funcNode.childForFieldName('argument');
            const methodNode = funcNode.childForFieldName('field');
            if (!objectNode || !methodNode) continue;

            if (methodNode.text !== originalName) continue;

            // field_expression structure: argument, operator, field
            const opNode = funcNode.child(1);
            const operator = opNode ? opNode.text : '.';

            const argsNode = callNode.childForFieldName('arguments');

            const result = transformCall(callNode, objectNode, argsNode, operator);
            if (result) helpers.replace(callNode, result);
        }
    });

    // 6. Special Handling for Defer
    if (!isExternDecl && originalName === 'Defer') {
        const deferHandler = (node, varName) => {
             const isConflict = upp.registry.helpers.replacements.some(r => {
                return (r.start < node.endIndex && r.end > node.startIndex);
            });
            if (isConflict) return null;

            return upp.code`${node} @defer ${newName}(&${varName});`;
        };

        const decls = upp.query(`
            (declaration
                type: (type_identifier) @type
                declarator: [(identifier) @id (init_declarator declarator: (identifier) @id)])
            @decl
        `, upp.root);

        for (const m of decls) {
            if (m.captures.type.text === cleanTarget) {
                const result = deferHandler(m.captures.decl, m.captures.id.text);
                if (result) upp.replace(m.captures.decl, result);
            }
        }
    } // End of !isExternDecl

    return outputText;

}

@define useCreate(T) {
    let node = upp.consume();
    let name, init;
    const text = node.text.trim();

    if (node.type === 'type_identifier' || node.type === 'identifier') {
        name = text;
        init = "= {0}";
        // Optional: consume the trailing semicolon if it exists to avoid ;;
        if (node.nextSibling && node.nextSibling.type === ';') {
            upp.replace(node.nextSibling, "");
        }
    } else {
        // Use [\s\S] to match across newlines
        const match = text.match(/^(\w+)\s*=\s*([\s\S]*);?$/);
        if (match) {
            name = match[1];
            init = ' = ' + match[2].replace(/;$/, '');
        } else {
            // Fallback: assume it's just the name if no equals sign found
            name = text.replace(';', '').trim();
            init = " = {0}";
        }
    }

    // Check for renamed symbol in the AST
    const renamedSymbol = `_${T}_method_Create`;
    const hasCreate = upp.query(`
        (function_definition
            declarator: (function_declarator
                declarator: (identifier) @name))
    `, upp.root).some(m => m.captures.name.text === renamedSymbol);

    if (hasCreate) {
        upp.replace({start: node.endIndex, end: node.endIndex}, ` ${name}.Create();`);
    }

    return upp.code`${T} ${name} ${init};`;
}

#endif
