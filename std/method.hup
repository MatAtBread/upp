@define method(targetType) {
    let node = upp.nextNode(['function_definition', 'declaration']);
    if (!node) {
        node = upp.findEnclosing(upp.contextNode, ['function_definition', 'declaration']);
    }
    if (!node) return "";

    const sig = upp.getFunctionSignature(node);
    if (!sig.nameNode) return node.text;

    const originalName = sig.name;
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }

    // Generate new name: _Point_method_getX
    const newName = `_${cleanTarget}_method_${originalName}`;

    // Rename the function identifier stable-y
    sig.nameNode.text = newName;

    // Use withPattern to transform method calls
    upp.withPattern('call_expression',
        (callNode, helpers) => {
            const funcNode = callNode.named['function'];
            if (!funcNode || funcNode.type !== 'field_expression') return false;

            const objectNode = funcNode.named['argument'];
            const methodNode = funcNode.named['field'];

            if (!objectNode || !methodNode) return false;
            if (methodNode.text !== originalName) return false;

            const objDef = helpers.findDefinitionOrNull(objectNode);
            if (!objDef) return false;

            let currentType = helpers.getType(objDef);
            let targetClean = targetType.replace(/struct /g, '').trim();

            while (currentType) {
                let clean = currentType.replace(/\*/g, '').replace(/struct /g, '').trim();
                if (clean === targetClean) return true;

                // Follow one level of typedef
                const def = helpers.findDefinitionOrNull(clean, { variable: true, tag: true });
                if (def && def.type === 'type_definition') {
                    currentType = helpers.getType(def);
                    continue;
                }
                break;
            }
            return false;
        },
        (callNode, helpers) => {
            const funcNode = callNode.named['function'];
            const targetNode = funcNode.named['argument'];
            const argsNode = callNode.named['arguments'];

            // Transform f.print() into _Foo_method_print(&f)
            let argsText = argsNode ? argsNode.text : "()";
            const separator = (argsText === "()") ? "" : ", ";
            const innerArgs = (argsText === "()") ? "" : argsText.slice(1, -1);
            
            const objDef = helpers.findDefinitionOrNull(targetNode);
            const objType = objDef ? helpers.getType(objDef, { resolve: true }) : "";
            
            // Use RegExp constructor to avoid UPP parser brace-counting bugs with /\{...\}/
            const bodyRegex = new RegExp('\\{[^}]*\\}', 'g');
            const cleanType = objType.replace(bodyRegex, '');
            const isPointer = cleanType.includes('*');
            const prefix = isPointer ? "" : "&";

            return `${newName}(${prefix}${targetNode.text}${separator}${innerArgs})`;
        }
    );

    return null; // Node already updated in-place
}
