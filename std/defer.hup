#ifndef __UPP_STDLIB_DEFER_H__
#define __UPP_STDLIB_DEFER_H__

@define defer() {
    const stmt = upp.consume(['expression_statement', 'compound_statement']);
    if (!stmt) return upp.error("Expected expression_statement or compound_statement");
    
    const code = stmt.text;

    upp.withScope((scope, helpers) => {
        const trimmed = code.trim();
        const codeText = (trimmed.endsWith('}') || trimmed.endsWith(';')) ? code : code + ";";
        
        // Find all return statements
        const returns = scope.find('return_statement');
        const returnOffsets = new Set();
        for (const node of returns) {
            helpers.replace(node, "\n" + codeText + "\n" + node.text);
            returnOffsets.add(node.startIndex);
        }

        // Also add before the closing brace of the scope
        const last = scope.children[scope.children.length - 1];
        if (last && last.type === '}' || last.type === 'compound_statement' && last.text === '}') {
            // Check if we already handled a return at the very end.
            // When we replace a return with 'code \n return', 
            // the original return node's identity is NOT necessarily preserved at the same position.
            // Let's check if the last non-comment, non-whitespace node is a return.
            let foundReturn = false;
            for (let i = scope.children.length - 1; i >= 0; i--) {
                const child = scope.children[i];
                if (child === last) continue;
                if (child.type === 'comment' || child.text.trim().length === 0) continue;
                
                if (child.type === 'return_statement') {
                    foundReturn = true;
                }
                break;
            }

            if (!foundReturn) {
                helpers.replace(last, codeText + "\n" + last.text);
            }
        }
    });

    return null;
}

#endif
