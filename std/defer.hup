#ifndef __UPP_STDLIB_DEFER_H__
#define __UPP_STDLIB_DEFER_H__

@define defer() {
    // Capture the exact location of the macro before consumption
    // This allows us to know if return statements appear AFTER this defer
    const deferIndex = upp.invocation.invocationNode.startIndex;
    
    const stmt = upp.consume(['expression_statement', 'compound_statement']);
    if (!stmt) return upp.error("Expected expression_statement or compound_statement");
    
    const code = stmt.text;
    const trimmed = code.trim();
    const codeText = (trimmed.endsWith('}') || trimmed.endsWith(';')) ? code : code + ";";
        
    const applyDeferToNode = (node) => {
        let defers = node.data._arrangedDefers || [];
        defers.push({ code: codeText, index: deferIndex });
        defers.sort((a, b) => b.index - a.index);
        node.data._arrangedDefers = defers;
        
        let existingNodes = node.data._insertedDeferNodes || [];
        const existingArr = Array.isArray(existingNodes) ? existingNodes : [existingNodes];
        existingArr.forEach(n => { if (n.isValid) n.remove(); });
        
        const fullDeferCode = defers.map(d => d.code).join('');
        node.data._insertedDeferNodes = node.insertBefore(upp.code`${fullDeferCode}`);
    };

    upp.withScope((scope, helpers) => {
        // Enforce no goto statements after the defer in this scope
        const gotos = scope.find('goto_statement').filter(n => n.startIndex > deferIndex);
        if (gotos.length > 0) {
            upp.error(gotos[0], "@defer does not yet support goto statements in its scope.");
        }

        // Find all return statements that occur AFTER this defer statement
        const returns = scope.find('return_statement').filter(n => n.startIndex > deferIndex);
        for (const node of returns) {
            applyDeferToNode(node);
        }

        // Also add before the closing brace of the scope
        const last = scope.children[scope.children.length - 1];
        if (last && (last.type === '}' || (last.type === 'compound_statement' && last.text === '}'))) {
            // Check if we already handled a return at the very end.
            let foundReturn = false;
            for (let i = scope.children.length - 1; i >= 0; i--) {
                const child = scope.children[i];
                if (child === last) continue;
                if (child.type === 'comment' || child.text.trim().length === 0) continue;
                
                if (child.type === 'return_statement') {
                    foundReturn = true;
                }
                break;
            }

            if (!foundReturn) {
                applyDeferToNode(last);
            }
        }
    });

    return null;
}

#endif
