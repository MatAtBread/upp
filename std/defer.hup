#ifndef __UPP_STDLIB_DEFER_H__
#define __UPP_STDLIB_DEFER_H__

@define defer() {
    console.log(`\\n=== @defer DEBUG ===`);
    console.log(`Invocation: start=${upp.invocation.startIndex}, end=${upp.invocation.endIndex}`);
    console.log(`lastConsumedNode: ${upp.lastConsumedNode ? upp.lastConsumedNode.type : 'null'}`);
    console.log(`contextNode: ${upp.contextNode ? upp.contextNode.type : 'null'}`);
    if (upp.contextNode) {
        console.log(`  contextNode.text: ${upp.contextNode.text.substring(0, 60)}...`);
        console.log(`  contextNode.range: [${upp.contextNode.startIndex}-${upp.contextNode.endIndex}]`);
    }
    console.log(`root.text: ${upp.root.text.substring(0, 100)}...`);
    console.log(`root.id: ${upp.root.id}, mainTree.id: ${upp.registry.mainTree.rootNode.id}`);
    console.log(`isNestedContext: ${upp.root.id !== upp.registry.mainTree.rootNode.id}`);

    const node = upp.consume();
    if (!node) return "";
    const deferredText = node.text;

    console.log(`Consumed node: type=${node.type}, range=[${node.startIndex}-${node.endIndex}]`);
    console.log(`  text: ${deferredText.substring(0, 60)}...`);
    console.log(`===================\\n`);

    const marker = upp.inScope((scope, helpers) => {
        console.log(`[@defer callback] Executing for scope type=${scope.type}, deferredText length=${deferredText.length}`);

        // Store the cleanup code in the task info so the registry can insert it
        const taskInfo = helpers.registry.deferredCallbacks.get(marker);
        if (taskInfo) {
            taskInfo.cleanupCode = deferredText;
            taskInfo.insertBeforeReturns = true;
            taskInfo.insertAtScopeEnd = true;
        }

        console.log(`[@defer callback] Stored cleanup code for later insertion`);
    });

    console.log(`[@defer] Returning marker: ${marker}`);
    return marker;
}

#endif
