#ifndef __UPP_STDLIB_LAMBDA_H__
#define __UPP_STDLIB_LAMBDA_H__

@define lambda() {
    // Use robust consume to find the target function definition
    const fnNode = upp.consume('function_definition', 'lambda expected function_definition');

    const sig = upp.getFunctionSignature(fnNode);
    const fnName = sig.name;
    const returnType = sig.returnType;
    let paramsText = sig.params;

    // Handle paramsText for context insertion
    if (paramsText.trim() === "()" || paramsText.trim() === "(void)") {
        paramsText = "";
    } else {
        paramsText = ", " + paramsText.trim().slice(1, -1);
    }

    const bodyNode = sig.bodyNode || (sig.node ? upp.childForFieldName(sig.node, 'body') : upp.childForFieldName(fnNode, 'body'));

    // 1. Identify captures
    const captureMap = new Map(); // name -> defNode

    const fnStart = fnNode.startIndex;
    const fnEnd = fnNode.endIndex;
    const isInsideFn = (n) => n.startIndex >= fnStart && n.endIndex <= fnEnd;

    upp.walk(bodyNode, (node) => {
        if (node.type === 'identifier') {
            const def = upp.getDefinition(node);
            // Use range check instead of isDescendant
            if (def && !isInsideFn(def)) {
                 captureMap.set(node.text, def);
            }
        }
    });

    // 2. Generate Context Struct
    const ctxName = captureMap.size > 0 ? upp.createUniqueIdentifier('lambda_ctx') : null;
    let structDef = "";
    if (ctxName) {
        let structFields = "";
        for (const [name, def] of captureMap) {
            let typeStr = upp.getType(def);
            structFields += `    ${typeStr} *${name};\n`;
        }
        structDef = `struct ${ctxName} {\n${structFields}\n};\n`;
    }

    // 3. Generate Hoisted Implementation
    const implName = upp.createUniqueIdentifier(`${fnName}_impl`);

    const hoistReplacements = [];
    upp.walk(bodyNode, (node) => {
        if (node.type === 'identifier' && captureMap.has(node.text)) {
            const def = upp.getDefinition(node);
            if (def && !isInsideFn(def)) {
                 hoistReplacements.push({
                     start: node.startIndex,
                     end: node.endIndex,
                     text: ctxName ? `(*ctx->${node.text})` : node.text
                 });
            }
        }
    });

    hoistReplacements.sort((a, b) => b.start - a.start);

    let bodyText = bodyNode.text;
    const bodyStart = bodyNode.startIndex;

    for (const r of hoistReplacements) {
        const relStart = r.start - bodyStart;
        const relEnd = r.end - bodyStart;
        bodyText = bodyText.slice(0, relStart) + r.text + bodyText.slice(relEnd);
    }

    const ctxParam = ctxName ? `struct ${ctxName} *ctx` : "";
    let finalParams = paramsText;
    if (ctxParam) {
        finalParams = ctxParam + (paramsText.startsWith(",") ? paramsText : (paramsText ? ", " + paramsText : ""));
    } else if (paramsText.startsWith(",")) {
        finalParams = paramsText.slice(1).trim();
    }

    const implCode = `\n${returnType} ${implName}(${finalParams}) ${bodyText}\n`;

    const hoistCode = "\n" + structDef + implCode;

    upp.atRoot((root, helpers) => {
        // Prepend struct and impl to root
        helpers.replace({ start: 0, end: 0 }, hoistCode);

        // 4. Replace Usage & Recursively Handle Aliases
        const contextArg = ctxName ? `(&ctx)` : "";
        const processedNodes = new Set();

        function processReferences(targetDefName, isOriginal) {
            helpers.walk(root, (ref) => {
                if (ref.type !== 'identifier') return;
                if (ref.text !== targetDefName) return;

                // For original name, skip inside the already removed function body
                // (though fnNode index might be stale, we can check if it's in a range)
                // Actually, since we are in a fresh tree, we just look for usages.

                const refParent = helpers.parent(ref);
                if (!refParent) return;

                // Usage Type 1: Function Call -> target(...)
                if (refParent.type === 'call_expression' && helpers.childForFieldName(refParent, 'function') === ref) {
                     const call = refParent;
                     const args = helpers.childForFieldName(call, 'arguments');
                     let newArgs = "";

                     if (contextArg) {
                        newArgs = contextArg;
                        if (helpers.childCount(args) > 2) {
                            const inner = args.text.slice(1, -1);
                            newArgs = `(${contextArg.slice(1, -1)}, ${inner})`;
                        }
                     } else {
                        newArgs = args.text;
                     }

                     const replacementName = isOriginal ? implName : ref.text;
                     helpers.replace(call, `${replacementName}${newArgs}`);
                     return;
                }

                // Usage Type 2: Alias Initialization / Declaration
                if (refParent.type === 'init_declarator' && helpers.childForFieldName(refParent, 'value') === ref) {
                     const initDecl = refParent;
                     const declStmt = helpers.parent(initDecl);
                     const decl = helpers.childForFieldName(initDecl, 'declarator');
                     let foundAlias = null;
                     helpers.walk(decl, n => { if (n.type === 'identifier' && !foundAlias) foundAlias = n; });
                     let aliasId = foundAlias;

                     if (isOriginal && aliasId && declStmt && declStmt.type === 'declaration') {
                          let prefix = "";
                          for(let i=0; i<helpers.childCount(declStmt); i++) {
                              const c = helpers.child(declStmt, i);
                              if (c.type === 'storage_class_specifier' || c.type === 'type_qualifier') {
                                  prefix += c.text + " ";
                              }
                          }
                          const newDecl = `${prefix}typeof(&${implName}) ${aliasId.text} = ${implName};`;
                          helpers.replace(declStmt, newDecl);
                          if (aliasId) processReferences(aliasId.text, false);
                          return;
                     } else if (aliasId) {
                          processReferences(aliasId.text, false);
                     }
                }
                // Usage Type 3: Assignment
                else if (refParent.type === 'assignment_expression' && helpers.childForFieldName(refParent, 'right') === ref) {
                     const left = helpers.childForFieldName(refParent, 'left');
                     let aliasId = null;
                     if (left.type === 'identifier') aliasId = left;
                     if (isOriginal) helpers.replace(ref, implName);
                     if (aliasId) {
                         processReferences(aliasId.text, false);
                     }
                }
                else if (isOriginal) {
                    helpers.replace(ref, implName);
                }
            });
        }

        processReferences(fnName, true);
    });

    // 5. Replace Definition
    let initCode = "";
    if (ctxName) {
        const captureList = Array.from(captureMap.keys());
        let initFields = captureList.map(name => `.${name} = &${name}`).join(', ');
        initCode = `struct ${ctxName} ctx = { ${initFields} };`;
    }

    upp.replace(fnNode, "");

    return initCode;
}

#endif
