#ifndef __UPP_STDLIB_ASYNC_H__
#define __UPP_STDLIB_ASYNC_H__

@define async() {
    let node = upp.consume(['function_definition', 'declaration']);
    node = (node.type === 'expression_statement' || node.type === 'declaration') ? node.child(0) : node;
    const declarator = node.childForFieldName('declarator');
    // Find the identifier within the potentially complex declarator
    const idMatches = upp.query(`(identifier) @id`, declarator);
    if (idMatches.length === 0) return "";

    const idNode = idMatches[0].captures.id;
    const name = idNode.text;

    // Use withReferences to transform call sites
    upp.withReferences(idNode, (refNode, helpers) => {
        // Find the call_expression ancestor
        let callNode = refNode;
        while (callNode && callNode.type !== 'call_expression' && callNode.startIndex === refNode.startIndex) {
            callNode = callNode.parent;
        }

        if (callNode && callNode.type === 'call_expression') {
            const funcNode = helpers.childForFieldName(callNode, 'function');
            // Ensure we are the function being called, not an argument
            if (funcNode && (funcNode === refNode || helpers.isDescendant(funcNode, refNode))) {
                helpers.replace(callNode, helpers.code`os_start(${name})`);
                return undefined; // Skip default replacement of the identifier itself
            }
        }
    });

    return node.text;
}

#endif
