#ifndef __UPP_STDLIB_ASYNC_H__
#define __UPP_STDLIB_ASYNC_H__

@define async() {
    const node = upp.contextNode;
    let def = (node.type === 'expression_statement' || node.type === 'declaration') ? node.child(0) : node;
    // Note: function_definition is usually top-level, but check anyway
    if (node.type !== 'function_definition') {
        upp.error(node, `@async must be applied to a function definition, not ${node.type}`);
    }
    let name = "";
    // Save the range of the definition to avoid self-transforming the declarator
    const defStart = node.startIndex;
    const defEnd = node.endIndex;

    const declarator = node.childForFieldName('declarator');
    // Find the identifier within the potentially complex declarator
    const idMatches = upp.query(`(identifier) @id`, declarator);
    if (idMatches.length > 0) {
        name = idMatches[0].captures.id.text;
    }

    // Find all references to this function in the WHOLE tree
    if (name) {
        upp.registerTransform((root, helpers) => {
            const calls = helpers.query(`(call_expression function: (identifier) @id) @call`, root);
            for (const m of calls) {
                const callNode = m.captures.call;
                if (m.captures.id.text === name) {
                    const isInside = callNode.startIndex >= defStart && callNode.endIndex <= defEnd;
                    if (!isInside) {
                        helpers.replace(callNode, helpers.code`os_start(${name})`);
                    }
                }
            }
        });
    }


    return "";
}

#endif
