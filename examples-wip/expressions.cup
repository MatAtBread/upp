#include "../examples/io-lite.h"

@include(fieldsof.hup)
@include(defer.hup)

struct _ReferenceCount {
  int ref_count;
};

void *_Managed_allocate(int size) {
  int *p = malloc(size);
  p[0] = 1;
  printf("%p [%d] Allocate %d bytes\n", p, p[0],size);
  return (void *)p;
}

void *_Managed_retain(struct _ReferenceCount *p) {
  p->ref_count++;
  printf("%p [%d] Retain\n", p, p->ref_count);
  return p;
}

void _Managed_release(void **_p) {
  struct _ReferenceCount *p = (struct _ReferenceCount *)*_p;
  if (p) {
    p->ref_count--;
    printf("%p [%d] Release\n", p, p->ref_count);
    if (p->ref_count <= 0) {
      free(p);
      *_p = NULL;
    }
  } else {
    printf("NULL release\n");
  }
}

void *_Managed_set(void *_dest, struct _ReferenceCount *_src) {
  struct _ReferenceCount **dest = _dest;
  printf("%p [%d] Set\n", *dest, (*dest)->ref_count);
  
  if (*dest) _Managed_release(dest);
  return *dest = (_src ? _Managed_retain(_src) : NULL);
}

@define ReferenceCounted() {
    const name = upp.consume().text;
    upp.withMatch(upp.root, `${name} $id;`, ({id}, upp, node) => {
        const def = upp.code`
    ${name} ${id.text} = _Managed_allocate(sizeof(*${id.text}));
    @defer _Managed_release(&${id.text});
    `;
    
        // Extract id.text early, because the matched node will be replaced and invalidated
        const nameText = id.text;
        
        // We use `node` (the original matched declaration in the AST) so eager sweep correctly resolves existing references.
        upp.withReferences(node, (ref, upp)=>{
          console.log("***",ref.parent.type);
                if (ref.parent.type === 'assignment_expression'
                && ref.parent.named.left === ref) {
                    return upp.withNode(ref.parent, (parent, upp)=>{
                        // children array might contain zero-length implicit semicolons from macro evaluation
                        const eqIndex = parent.children.findIndex(c => c.type === '=');
                        const rhsNodes = parent.children.slice(eqIndex + 1).filter(c => c.text.length > 0);
                        const rhs = rhsNodes.length === 1 ? rhsNodes[0] : rhsNodes;
                        return upp.code`_Managed_set(&${nameText}, ${rhs})`;
                    })
                }
                if (ref.parent.type === 'argument_list') {
                    return upp.code`_Managed_retain(${nameText})`;
                }
                if (ref.parent.type == 'parameter_declaration') {
                    return upp.code`@defer _Managed_release(&${nameText})`;
                }
                return undefined;//upp.code`_get(${nameText})`;
            });
            
        return def;
    });
    return null;
}

@define ManagedStruct(T) {
    const name = upp.consume().text;
    return $`
typedef struct { @fieldsof(struct _ReferenceCount); @fieldsof(${T}); } *${name};
@ReferenceCounted ${name}
`;
}

typedef struct Point_s {
    int x;
    int y;
} Point;

@ManagedStruct(Point) PointRef;

void f(PointRef p) {
    printf("%d\n", p->x);
}

int main() {
    printf("ok\n");
    PointRef p;
    PointRef q;
    p->x = 1;
    f(p);
    q = p;
    p = NULL;
    return 0;
}
