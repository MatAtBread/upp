#include "io-lite.h"

@include(fieldsof.hup)
@include(defer.hup)
@include(method.hup)

struct _ReferenceCount {
  int ref_count;
};

static inline void *_Managed_allocate(int size) {
  struct _ReferenceCount *p = malloc(size);
  p->ref_count = 1;
  printf("[%d] Allocate %d bytes\n", p->ref_count,size);
  return (void *)p;
}

static inline void *_Managed_retain(struct _ReferenceCount *p) {
  p->ref_count++;
  printf("[%d] Retain\n", p->ref_count);
  return p;
}

static inline void _Managed_release(void **_p) {
  struct _ReferenceCount *p = (struct _ReferenceCount *)*_p;
  if (p) {
    p->ref_count--;
    printf("[%d] Release\n", p->ref_count);
    if (p->ref_count <= 0) {
      free(p);
      *_p = NULL;
    }
  } else {
    printf("NULL release\n");
  }
}

static inline void *_Managed_set(void *_dest, struct _ReferenceCount *_src) {
  struct _ReferenceCount **dest = _dest;
  
  if (*dest) { 
    printf("[%d] Set\n", (*dest)->ref_count);
    _Managed_release(dest);
  }
  return *dest = (_src ? _Managed_retain(_src) : NULL);
}

@define ReferenceCounted() {
  const name = upp.consume().text;
  upp.withMatch(upp.root, `${name} $id`, ({ id }, upp, node) => {
    let nameText = id.text;

    const handleReference = (ref, upp) => {
      if (ref.parent.type === 'assignment_expression' && ref.parent.named.left === ref) {
        return upp.withNode(ref.parent, (parent, upp) => {
          const eqIndex = parent.children.findIndex(c => c.type === '=');
          const rhsNodes = parent.children.slice(eqIndex + 1).filter(c => c.text.length > 0);
          const rhs = rhsNodes.length === 1 ? rhsNodes[0] : rhsNodes;
          return upp.code`_Managed_set(&${nameText}, ${rhs})`;
        })
      }
      if (ref.parent.type === 'return_statement') {
        upp.withNode(ref.parent, (node, upp) => {
          node.insertBefore(upp.code`_Managed_retain(${nameText});`);
        })
      }
      return undefined;
    };

    // If it's a parameter, we don't want to re-declare or re-allocate it.
    // We just want to track its references.
    if (node.type === 'parameter_declaration') {
      upp.withReferences(node, handleReference);
      if (node.parent.parent.parent.type == 'function_definition') {
        upp.withNode(node.parent.parent.parent.named.body, (body, upp) => {
          return upp.code`{
          _Managed_retain(${nameText}); 
          @defer _Managed_release(&${nameText}); 
          ${body.children.slice(1, -1)}
          }`;
        });
      }
      return undefined; // Leave the parameter declaration as is.
    }

    upp.withReferences(node, handleReference);

    if (node.named.declarator.named.value) {
      nameText = node.named.declarator.named.declarator.text;
      return upp.code`
      ${name} ${nameText} = ${node.named.declarator.named.value};
      @defer _Managed_release(&${nameText});
      `;
    }
    return upp.code`
    ${name} ${nameText} = _Managed_allocate(sizeof(*${nameText}));
    @defer _Managed_release(&${nameText});
    `;
  });
  return null;
}

@define ManagedStruct(T) {
    const name = upp.consume().text.replace(/;$/, '');
    return $`
typedef struct { @fieldsof(struct _ReferenceCount); @fieldsof(${T}); } *${name};
@method(${name}) ${T}* struct(${name} p) {
    return (${T} *)((char *)p + sizeof(struct _ReferenceCount));
}
@ReferenceCounted ${name};
`;
}

typedef struct Point_s {
    int x;
    int y;
} Point;

@ManagedStruct(Point) PointRef;

@method(PointRef) void print(PointRef p, const char *s) {
    printf("%s (%d, %d)\n", s, p->x, p->y);
}

void fn(PointRef p) {
    printf("fn [%d] (%d, %d)\n", p->ref_count, p->x, p->y);
}

PointRef origin() {
    PointRef p;
    p->x = 0;
    p->y = 0;
    return p;
}

PointRef point(int x, int y) {
    PointRef p;
    p->x = x;
    p->y = y;
    return p;
}

int main() {
    PointRef p;
    PointRef q = origin(); 
    q = NULL;
    printf("q %p\n", q);
    p->x = 10;
    p->y = 20;
    fn(p);
    p.struct()->x = 100;
    p.print("p");
    q = origin("q");
    p = q;
    PointRef r = point(1, 2);
    r.print("r");
    p.print("p");
    return 0;
}
