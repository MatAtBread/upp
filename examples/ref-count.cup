#include "../examples/io-lite.h"

@include(fieldsof.hup)
@include(defer.hup)

struct _ReferenceCount {
  int ref_count;
};

void *_Managed_allocate(int size) {
  int *p = malloc(size);
  p[0] = 1;
  printf("%p [%d] Allocate %d bytes\n", p, p[0],size);
  return (void *)p;
}

void *_Managed_retain(struct _ReferenceCount *p) {
  p->ref_count++;
  printf("%p [%d] Retain\n", p, p->ref_count);
  return p;
}

void _Managed_release(void **_p) {
  struct _ReferenceCount *p = (struct _ReferenceCount *)*_p;
  if (p) {
    p->ref_count--;
    printf("%p [%d] Release\n", p, p->ref_count);
    if (p->ref_count <= 0) {
      free(p);
      *_p = NULL;
    }
  } else {
    printf("NULL release\n");
  }
}

void *_Managed_set(void *_dest, struct _ReferenceCount *_src) {
  struct _ReferenceCount **dest = _dest;
  printf("%p [%d] Set\n", *dest, (*dest)->ref_count);
  
  if (*dest) _Managed_release(dest);
  return *dest = (_src ? _Managed_retain(_src) : NULL);
}

@define ReferenceCounted() {
  const name = upp.consume().text;
  upp.withMatch(upp.root, `${name} $id`, ({ id }, upp, node) => {
    const nameText = id.text;

    const handleReference = (ref, upp) => {
      if (ref.parent.type === 'assignment_expression' && ref.parent.named.left === ref) {
        return upp.withNode(ref.parent, (parent, upp) => {
          const eqIndex = parent.children.findIndex(c => c.type === '=');
          const rhsNodes = parent.children.slice(eqIndex + 1).filter(c => c.text.length > 0);
          const rhs = rhsNodes.length === 1 ? rhsNodes[0] : rhsNodes;
          return upp.code`_Managed_set(&${nameText}, ${rhs})`;
        })
      }
      if (ref.parent.type === 'argument_list') {
        return upp.code`_Managed_retain(${nameText})`;
      }
      if (ref.parent.type === 'return_statement') {
        upp.withNode(ref.parent, (node, upp) => {
          node.insertBefore(upp.code`_Managed_retain(${nameText});`);
        })
      }
      return undefined;
    };

    // If it's a parameter, we don't want to re-declare or re-allocate it.
    // We just want to track its references.
    if (node.type === 'parameter_declaration') {
      upp.withReferences(node, handleReference);
      if (node.parent.parent.parent.type == 'function_definition') {
        upp.withNode(node.parent.parent.parent.named.body, (body, upp) => {
          return upp.code`{ @defer _Managed_release(&${nameText}); ${body.children.slice(1, -1)} }`;
        });
      }
      return undefined; // Leave the parameter declaration as is.
    }

    upp.withReferences(node, handleReference);

    if (node.named.declarator.named.value) {
      //console.log("***",node.text,JSON.stringify(node.named, null, 2));
      return undefined;
    }
    const def = upp.code`
    ${name} ${id.text} = _Managed_allocate(sizeof(*${id.text}));
    @defer _Managed_release(&${id.text});
    `;


    return def;
  });
  return null;
}

@define ManagedStruct(T) {
    const name = upp.consume().text;
    return $`
typedef struct { @fieldsof(struct _ReferenceCount); @fieldsof(${T}); } *${name};
@ReferenceCounted ${name}
`;
}

typedef struct Point_s {
    int x;
    int y;
} Point;

@ManagedStruct(Point) PointRef;

void f(PointRef p) {
    printf("%d\n", p->x);
}

PointRef origin() {
    PointRef p;
    p->x = 0;
    p->y = 0;
    return p;
}

int main() {
    // printf("ok\n");
    // PointRef p;
    // PointRef q;
    // p->x = 1;
    // f(p);
    // q = p;
    // p = NULL;
    //PointRef p;
    PointRef q = origin();
    return 0;
}
