#include "io-lite.h"

@define method(targetType) {
    const node = upp.consume();
    const funcDef = node;
    const funcDeclarator = funcDef.childForFieldName('declarator');
    const funcIdentifier = funcDeclarator.childForFieldName('declarator');
    const returnType = funcDef.childForFieldName('type');
    const params = funcDeclarator.childForFieldName('parameters');
    const body = funcDef.childForFieldName('body');

    const originalName = funcIdentifier.text;

    // Sanitize targetType to handle "struct Point" vs "Point"
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }
    const newName = `_${cleanTarget}_method_${originalName}`;

    // Use withPattern to transform method calls persistently
    upp.withPattern('call_expression',
        (call, helpers) => {
            const fn = call.childForFieldName('function');
            if (fn && fn.type === 'field_expression') {
                const field = fn.childForFieldName('field');
                if (field && field.text === originalName) {
                    const obj = fn.childForFieldName('argument');
                    // Simple heuristic: check if obj text matches a known var (limited in this example)
                    // In a full impl like std/method.hup, we'd check types.
                    return true;
                }
            }
            return false;
        },
        (call, helpers) => {
            const fn = call.childForFieldName('function');
            const obj = fn.childForFieldName('argument');
            const args = call.childForFieldName('arguments');
            const operator = fn.text.includes('->') ? '->' : '.';
            const objRef = operator === '.' ? `&(${obj.text})` : obj.text;
            const argsText = args.text.slice(1, -1);
            const finalArgs = objRef + (argsText.trim() ? ', ' + argsText : '');
            return helpers.code`${newName}(${finalArgs})`;
        }
    );

    if (originalName === 'Defer') {
        const declarations = upp.root.find('declaration');
        for (const declNode of declarations) {
            const typeNode = declNode.childForFieldName('type');
            if (typeNode && typeNode.text === cleanTarget) {
                const ids = declNode.find('identifier');
                for (const id of ids) {
                    if (id.parent.type.includes('declarator') || id.parent === declNode) {
                        declNode.insertAfter(upp.code`@defer ${id.text}.Defer();`);
                    }
                }
            }
        }
    }

    return upp.code`${returnType.text} ${newName}${params.text} ${body.text}`;
}

@define defer() {
    const node = upp.consume();
    const scope = upp.findEnclosing(upp.invocation.invocationNode, 'compound_statement');
    if (!scope) return;

    const absStart = (node.tree && node.tree === upp.root.tree) ? node.startIndex : upp.invocation.startIndex;

    // Use withPattern to catch all returns in this scope
    upp.withPattern('return_statement',
        (m, helpers) => {
            // Only transform returns that come AFTER this defer in the SAME scope/function
            return m.startIndex > absStart && helpers.findEnclosing(m, 'compound_statement') === scope;
        },
        (m, helpers) => {
            // Replace return with { defer_code; return; } to avoid infinite recursion
            return helpers.code`{ ${node.text} ${m.text} }`;
        }
    );

    // Also handle the end of scope
    const lastBrace = scope.children.find(c => c.text === '}');
    if (lastBrace) {
        lastBrace.insertBefore(upp.code`${node.text} `);
    }
}

typedef struct String String;
struct String {
    char * data;
};

@method(String) void Defer(String * s) {
    printf("Freeing string: %s\n", s -> data);
    free(s -> data);
}

int main() {
    String s1;
    s1.data = malloc(100);
    strcpy(s1.data, "Hello");

    int some_condition = 0;
    if (some_condition) {
        return 1;
    }

    return 0;
}
