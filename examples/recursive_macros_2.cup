#include "io-lite.h"

@define method(targetType) {
    const node = upp.consume();
    const funcDef = node;
    const funcDeclarator = funcDef.childForFieldName('declarator');
    const funcIdentifier = funcDeclarator.childForFieldName('declarator');
    const returnType = funcDef.childForFieldName('type');
    const params = funcDeclarator.childForFieldName('parameters');
    const body = funcDef.childForFieldName('body');

    const originalName = funcIdentifier.text;

    // Sanitize targetType to handle "struct Point" vs "Point"
    let cleanTarget = targetType.trim();
    if (cleanTarget.startsWith('struct ')) {
        cleanTarget = cleanTarget.slice(7).trim();
    }
    const newName = `_${cleanTarget}_method_${originalName}`;

    upp.registerTransform((root, helpers) => {
        const calls = root.find('call_expression');
        for (const call of calls) {
            const fn = call.childForFieldName('function');
            if (fn && fn.type === 'field_expression') {
                const field = fn.childForFieldName('field');
                if (field && field.text === originalName) {
                    const obj = fn.childForFieldName('argument');
                    const args = call.childForFieldName('arguments');
                    // Check if dot or arrow
                    const operator = fn.text.includes('->') ? '->' : '.';
                    const objRef = operator === '.' ? `&(${obj.text})` : obj.text;
                    const argsText = args.text.slice(1, -1);
                    const finalArgs = objRef + (argsText.trim() ? ', ' + argsText : '');
                    helpers.replace(call, helpers.code`${newName}(${finalArgs})`);
                }
            }
        }
    });

    if (originalName === 'Defer') {
        const declarations = upp.root.find('declaration');
        for (const declNode of declarations) {
            const typeNode = declNode.childForFieldName('type');
            if (typeNode && typeNode.text === cleanTarget) {
                // Find identifiers in this declaration
                const ids = declNode.find('identifier');
                for (const id of ids) {
                    // Check if it's a declarator (heuristic)
                    if (id.parent.type.includes('declarator') || id.parent === declNode) {
                        const varName = id;
                        declNode.insertAfter(upp.code`@defer ${varName}.Defer();`);
                    }
                }
            }
        }
    }

    return upp.code`${returnType.text} ${newName}${params.text} ${body.text}`;
}

@define defer() {
    const node = upp.consume();
    const scope = upp.findEnclosing(upp.invocation.invocationNode, 'compound_statement');
    if (!scope) return;

    const absStart = (node.tree && node.tree === upp.root.tree) ? node.startIndex : upp.invocation.startIndex;

    upp.registerTransform((root, helpers) => {
        const functions = root.find('function_definition');
        let targetBody = null;
        for (const f of functions) {
            const sig = helpers.getFunctionSignature(f);
            if (sig.bodyNode && sig.bodyNode.startIndex <= absStart && sig.bodyNode.endIndex >= absStart) {
                targetBody = sig.bodyNode;
                break;
            }
        }

        if (!targetBody) return;

        const matches = targetBody.find('return_statement');
        for (const m of matches) {
            if (m.startIndex > absStart) {
                m.insertBefore(upp.code`${node.text} `);
            }
        }

        const lastBrace = targetBody.children.find(c => c.text === '}');
        if (lastBrace) {
            lastBrace.insertBefore(upp.code`${node.text} `);
        }
    });
}

typedef struct String String;
struct String {
    char * data;
};

@method(String) void Defer(String * s) {
    printf("Freeing string: %s\n", s -> data);
    free(s -> data);
}

int main() {
    String s1;
    s1.data = malloc(100);
    strcpy(s1.data, "Hello");

    int some_condition = 0;
    if (some_condition) {
        return 1;
    }

    return 0;
}
