// Generated by dts-bundle-generator v9.5.1

import Parser from 'tree-sitter';
import { SyntaxNode, Tree } from 'tree-sitter';

export interface DiagnosticsConfig {
	suppress?: string[];
}
declare class DiagnosticsManager {
	private suppressed;
	/**
	 * @param {DiagnosticsConfig} [config={}] - Configuration object with suppression list.
	 */
	constructor(config?: DiagnosticsConfig);
	/**
	 * Reports a warning if not suppressed.
	 * @param {string | number} code - The diagnostic code (e.g., UPP001).
	 * @param {string} message - The warning message.
	 * @param {string} filePath - File where warning occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code for context.
	 */
	reportWarning(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null): void;
	/**
	 * Reports an error and optionally exits.
	 * @param {string | number} code - The diagnostic code.
	 * @param {string} message - The error message.
	 * @param {string} filePath - File where error occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code.
	 * @param {boolean} [fatal=true] - Whether to exit the process.
	 */
	reportError(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null, fatal?: boolean): void;
	/**
	 * Helper to calculate line and column from character index.
	 * @param {string} source - Source code.
	 * @param {number} index - Character index.
	 * @returns {{line: number, col: number}} 1-indexed line and col.
	 */
	static getLineCol(source: string, index: number): {
		line: number;
		col: number;
	};
}
export interface CacheData {
	macros: Macro[];
	transformRules: TransformRule[];
	output: string;
	shouldMaterialize: boolean;
	isAuthoritative: boolean;
}
declare class DependencyCache {
	private cache;
	constructor();
	/**
	 * Checks if a file is in the cache.
	 * @param {string} filePath - Absolute path.
	 * @returns {boolean}
	 */
	has(filePath: string): boolean;
	/**
	 * Gets data for a file.
	 * @param {string} filePath
	 * @returns {CacheData | undefined}
	 */
	get(filePath: string): CacheData | undefined;
	/**
	 * Sets data for a file.
	 * @param {string} filePath
	 * @param {CacheData} data
	 */
	set(filePath: string, data: CacheData): void;
}
export interface MaterializeOptions {
	isAuthoritative: boolean;
}
export interface PatternMatchableNode {
	type: string;
	text: string;
	childCount: number;
	child(index: number): PatternMatchableNode | null;
}
export interface Macro {
	name: string;
	params: string[];
	body: string;
	language: string;
	origin: string;
	startIndex: number;
}
export interface TransformRule<T extends string = string> {
	active: boolean;
	matcher: (node: SourceNode<T>, helpers: any) => boolean;
	callback: (node: SourceNode<T>, helpers: any) => SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined;
}
export interface Invocation {
	name: string;
	args: string[];
	startIndex: number;
	endIndex: number;
	line?: number;
	col?: number;
	invocationNode?: SourceNode<any>;
}
export interface RegistryConfig {
	onMaterialize?: (outputPath: string, content: string, options: MaterializeOptions) => void;
	filePath?: string;
	stdPath?: string;
	cache?: DependencyCache;
	diagnostics?: DiagnosticsManager;
	suppress?: string[];
	comments?: boolean;
}
export interface Marker<T extends string = string> {
	callback: (node: SourceNode<T>, helpers: any) => SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined;
	data?: unknown;
}
export interface RegistryContext {
	source: string;
	tree: SourceTree<any>;
	originPath: string;
	invocations: Invocation[];
	helpers: UppHelpersBase<any> | null;
}
export type TreeSitterLang = unknown;
declare class Registry {
	config: RegistryConfig;
	parentRegistry: Registry | null;
	depth: number;
	filePath: string;
	diagnostics: DiagnosticsManager;
	language: TreeSitterLang;
	helpers: UppHelpersBase<any> | null;
	parentHelpers: UppHelpersBase<any> | null;
	parentTree: SourceTree<any> | null;
	materializedFiles: Set<string>;
	isAuthoritative: boolean;
	macros: Map<string, Macro>;
	parser: Parser;
	idCounter: number;
	stdPath: string | null;
	loadedDependencies: Map<string, string>;
	shouldMaterializeDependency: boolean;
	transformRules: TransformRule<any>[];
	ruleIdCounter: number;
	isExecutingDeferred: boolean;
	onMaterialize: ((outputPath: string, content: string, options: {
		isAuthoritative: boolean;
	}) => void) | null;
	mainContext: RegistryContext | null;
	UppHelpersC: typeof UppHelpersC;
	source?: string;
	tree?: SourceTree<any>;
	deferredMarkers?: Marker<any>[];
	activeTransformNode?: SourceNode<any> | null;
	originPath?: string;
	constructor(config?: RegistryConfig, parentRegistry?: Registry | null);
	registerMacro(name: string, params: string[], body: string, language?: string, origin?: string, startIndex?: number): void;
	getMacro(name: string): Macro | undefined;
	registerTransformRule(rule: TransformRule<any> | ((node: SourceNode<any>, helpers: any) => SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined)): void;
	loadDependency(file: string, originPath?: string, parentHelpers?: UppHelpersBase<any> | null): void;
	generateRuleId(): string;
	transform(source: string, originPath?: string, parentHelpers?: UppHelpersBase<any> | null): string;
	transformNode(node: SourceNode<any>, helpers: any, context: RegistryContext): void;
	executeDeferredMarkers(helpers: any): void;
	evaluateMacro(invocation: Invocation, source: string, helpers: any, filePath: string): SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined;
	createMacroFunction(macro: Macro): Function;
	prepareSource(source: string, originPath: string): {
		cleanSource: string;
		invocations: Invocation[];
	};
	extractBody(source: string, startOffset: number): string;
	findInvocations(source: string, tree?: Parser.Tree | null): Invocation[];
	absorbInvocation(text: string, startIndex: number): {
		name: string;
		args: string[];
	} | null;
	isInsideInvocation(_start: number, _end: number): boolean;
}
declare class SourceTree<NodeTypes extends string = string> {
	source: string;
	language: any;
	parser: Parser;
	tree: Parser.Tree;
	nodeCache: Map<number | string, SourceNode<any>>;
	root: SourceNode<NodeTypes>;
	/**
	 * @param {string} source Initial source code text.
	 * @param {any} language Tree-sitter language object.
	 */
	constructor(source: string, language: any);
	/**
	 * Internal method to get or create a SourceNode wrapper for a Tree-sitter node.
	 * @param {SyntaxNode | null} tsNode The Tree-sitter node to wrap.
	 * @param {SourceNode | null} [parent] The parent SourceNode, if any.
	 * @param {string | null} [fieldName] The field name for this node in the parent.
	 * @returns {SourceNode|null}
	 */
	wrap<K extends NodeTypes>(tsNode: Parser.SyntaxNode | null, parent?: SourceNode<any> | null, fieldName?: string | null): SourceNode<K> | null;
	/**
	 * Apply a specialized splice to the source string and update tracking for all active nodes.
	 * @param {number} start The start index of the edit.
	 * @param {number} end The end index of the edit.
	 * @param {string} newText The replacement text.
	 */
	edit(start: number, end: number, newText: string): void;
	/** @returns {number} */
	get startIndex(): number;
	/** @returns {number} */
	get endIndex(): number;
	/** @returns {string} */
	get type(): string;
	/** @returns {SourceNode<any>[]} */
	get children(): SourceNode<any>[];
	/** @returns {string} */
	get text(): string;
	/** @param {string} val */
	set text(val: string);
	/**
	 * Creates a SourceNode from a code fragment.
	 * Tries to parse as valid code; if it fails, wraps in a dummy function to parse statements/expressions.
	 * @param {string | SourceNode<any> | SourceTree<any>} code The text fragment to parse.
	 * @param {any} language Tree-sitter language object.
	 * @returns {SourceNode<any>}
	 */
	static fragment<K extends string = string>(code: string | SourceNode<any> | SourceTree<any>, language: any): SourceNode<K>;
	/**
	 * Serializes the tree to JSON, avoiding circular references.
	 * @returns {Object}
	 */
	toJSON(): any;
	/**
	 * Merges current tree's nodes into another target SourceTree.
	 * @param {SourceTree<any>} targetTree The tree to merge into.
	 * @param {number} offset The offset to apply to all migrated nodes.
	 */
	mergeInto(targetTree: SourceTree<any>, offset: number): void;
}
declare class SourceNode<T extends string = string> {
	tree: SourceTree<any>;
	id: number | string;
	type: T;
	startIndex: number;
	endIndex: number;
	children: SourceNode<any>[];
	parent: SourceNode<any> | null;
	fieldName: string | null;
	markers: Marker<T>[];
	data: Record<string, unknown>;
	_capturedText?: string;
	_snapshotSearchable?: string;
	/**
	 * @param {SourceTree<any>} tree The tree this node belongs to.
	 * @param {SyntaxNode} tsNode The Tree-sitter node to wrap.
	 */
	constructor(tree: SourceTree<any>, tsNode: Parser.SyntaxNode);
	/** @returns {boolean} */
	get isNamed(): boolean;
	/** @returns {boolean} */
	get isValid(): boolean;
	/** @returns {SourceNode<any>|null} */
	get nextNamedSibling(): SourceNode<any> | null;
	/** @returns {SourceNode<any>|null} */
	get prevNamedSibling(): SourceNode<any> | null;
	/** @returns {number} */
	get namedChildCount(): number;
	/**
	 * @param {number} idx
	 * @returns {SourceNode<any>|null}
	 */
	namedChild(idx: number): SourceNode<any> | null;
	/** @returns {SourceNode<any>|null} */
	get firstNamedChild(): SourceNode<any> | null;
	toString(): string;
	/** @returns {string} */
	get text(): string;
	/**
	 * Returns the name to use for symbol resolution.
	 * Prioritizes _capturedText to allow resolution by original name after a rename.
	 * @returns {string}
	 */
	get searchableText(): string;
	/** @param {string} value */
	set text(value: string);
	/** @returns {number} */
	get childCount(): number;
	get named(): Record<string, SourceNode<any>>;
	/**
	 * @returns {Object}
	 */
	toJSON(): Object;
	/**
	 * @param {number} idx
	 * @returns {SourceNode<any>}
	 */
	child(idx: number): SourceNode<any>;
	/**
	 * Internal method called by SourceTree when a global edit happens.
	 * @param {number} editStart The start index of the edit.
	 * @param {number} editEnd The end index of the edit.
	 * @param {number} delta Offset change duration.
	 */
	handleEdit(editStart: number, editEnd: number, delta: number): void;
	/**
	 * Removes the node from the tree and returns the removed sub-tree.
	 * @returns {SourceTree<T>}
	 */
	remove(): SourceTree<T>;
	/**
	 * Recursively invalidates this node and its children,
	 * removing them from the tree cache.
	 * @private
	 */
	_invalidateRecursively(): void;
	/**
	 * Replaces this node with another node or text.
	 * @param {SourceNode<any>|SourceTree<any>|string|Array<SourceNode<any>|string>} newNodeContent The node or text to replace with.
	 * @returns {SourceNode<any> | SourceNode<any>[] | null}
	 */
	replaceWith(newNodeContent: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>): SourceNode<any> | SourceNode<any>[] | null;
	/**
	 * Inserts a node or text after this node.
	 * @param {SourceNode<any>|SourceTree<any>|string} newNode The node or text to insert.
	 * @returns {SourceNode<any>|SourceNode<any>[]}
	 */
	insertAfter(newNode: SourceNode<any> | SourceTree<any> | string): SourceNode<any> | SourceNode<any>[];
	/**
	 * Inserts a node or text before this node.
	 * @param {SourceNode<any>|SourceTree<any>|string} newNode The node or text to insert.
	 * @returns {SourceNode<any>|SourceNode<any>[]}
	 */
	insertBefore(newNode: SourceNode<any> | SourceTree<any> | string): SourceNode<any> | SourceNode<any>[];
	_attachNewNode(newNode: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>, insertionOffset: number): SourceNode<any> | SourceNode<any>[] | null;
	/**
	 * Finds nodes matching a predicate or type within this subtree.
	 * @param {string|function(SourceNode<any>):boolean} predicate Type name or filter function.
	 * @returns {SourceNode<any>[]}
	 */
	find<K extends string = string>(predicate: K | ((n: SourceNode<any>) => boolean)): SourceNode<K>[];
	/**
	 * Finds the smallest descendant that contains the given index range.
	 * @param {number} start
	 * @param {number} end
	 * @returns {SourceNode<any>}
	 */
	descendantForIndex(start: number, end: number): SourceNode<any>;
	childForFieldName(fieldName: string): SourceNode<any> | null;
	/**
	 * Finds a direct child by its field name.
	 * @param {string} fieldName
	 * @returns {SourceNode<any>|null}
	 */
	findChildByFieldName(fieldName: string): SourceNode<any> | null;
	/**
	 * Appends a node or text as a child of this node.
	 * Requires the node to already have children to use as anchors.
	 * @param {SourceNode<any>|SourceTree<any>|string} newNode The node or text to append.
	 * @returns {SourceNode<any> | SourceNode<any>[] | null}
	 */
	append(newNode: SourceNode<any> | SourceTree<any> | string): SourceNode<any> | SourceNode<any>[] | null;
}
declare class UppHelpersBase<LanguageNodeTypes extends string> {
	root: SourceNode<LanguageNodeTypes> | null;
	registry: Registry;
	_parentHelpers: UppHelpersBase<any> | null;
	contextNode: SourceNode<any> | null;
	invocation: Invocation | null;
	lastConsumedNode: SourceNode<LanguageNodeTypes> | null;
	isDeferred: boolean;
	currentInvocations: Invocation[];
	consumedIds: Set<number | string>;
	context: RegistryContext | null;
	parentTree: SourceNode<any> | null;
	stdPath: string | null;
	lastConsumedIndex?: number;
	parentRegistry?: {
		invocations: Invocation[];
		sourceCode: string;
		helpers: UppHelpersBase<any>;
	};
	topLevelInvocation?: Invocation | null;
	get parentHelpers(): UppHelpersBase<any> | null;
	set parentHelpers(v: UppHelpersBase<any> | null);
	get isAuthoritative(): boolean;
	set isAuthoritative(v: boolean);
	constructor(root: SourceNode<LanguageNodeTypes> | null, registry: Registry, parentHelpers?: UppHelpersBase<any> | null);
	code(strings: TemplateStringsArray, ...values: any[]): SourceNode<LanguageNodeTypes>;
	atRoot(callback: (root: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	withScope(callback: (scope: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	withRoot(callback: (root: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	/**
	 * @deprecated Use code or withPattern instead.
	 */
	registerTransform(callback: (root: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	registerTransformRule(rule: any): void;
	replace(n: SourceNode<any>, newContent: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any> | null): SourceNode<any> | SourceNode<any>[] | null;
	insertBefore(n: SourceNode<any>, content: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any>): SourceNode<any> | SourceNode<any>[];
	insertAfter(n: SourceNode<any>, content: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any>): SourceNode<any> | SourceNode<any>[];
	findRoot(): SourceNode<LanguageNodeTypes> | null;
	withNode(node: SourceNode<any> | null, callback: (target: SourceNode<any>, helpers: any) => any): string;
	wrapNode<K extends LanguageNodeTypes>(node: SourceNode<any>): SourceNode<K>;
	/**
	 * Finds macro invocations in the tree.
	 * @param {string} macroName
	 * @param {SourceNode<any>} [node]
	 * @returns {any[]}
	 */
	findInvocations(macroName: string, node?: SourceNode<any> | null): Invocation[];
	loadDependency(file: string): void;
	/**
	 * Finds the next logical node after the macro invocation.
	 * @private
	 */
	_getNextNode(expectedTypes?: string[] | null): SourceNode<LanguageNodeTypes> | null;
	/**
	 * Retrieves the next node without removing it from the tree.
	 * @param {string|string[] | null} [types]
	 * @returns {SourceNode<LanguageNodeTypes>|null}
	 */
	nextNode(types?: string | string[] | null): SourceNode<LanguageNodeTypes> | null;
	consume(expectedTypeOrOptions?: string | string[] | {
		type?: string | string[];
		message?: string;
		validate?: (n: SourceNode<LanguageNodeTypes>) => boolean;
	}, errorMessage?: string): SourceNode<LanguageNodeTypes> | null;
	isDescendant(parent: SourceNode<any> | null, node: SourceNode<any>): boolean;
	walk(node: SourceNode<any>, callback: (n: SourceNode<any>) => void): void;
	parent(node: SourceNode<any>): SourceNode<any> | null;
	childForFieldName(node: SourceNode<any> | null, fieldName: string): SourceNode<any> | null;
	findNextNodeAfter(root: SourceNode<any> | null, index: number): SourceNode<any> | null;
	findScope(): SourceNode<LanguageNodeTypes> | null;
	findEnclosing(node: SourceNode<any>, types: string | string[]): SourceNode<LanguageNodeTypes> | null;
	createUniqueIdentifier(prefix?: string): string;
	childCount(node: SourceNode<any> | null): number;
	child(node: SourceNode<any> | null, index: number): SourceNode<any> | null;
	error(node: SourceNode<any> | string, message?: string): never;
}
export interface ConstraintSpec {
	type: string;
	not: boolean;
}
export type ConstraintMap = Map<string, ConstraintSpec[]>;
export interface CaptureResult {
	node?: PatternMatchableNode;
	[key: string]: any;
}
declare class PatternMatcher {
	private parseFn;
	private cache;
	private language;
	/**
	 * @param {function(string): Tree} parseFn - Function to parse a code fragment.
	 * @param {any} language - The language object.
	 */
	constructor(parseFn: (code: string) => Parser.Tree, language: any);
	/**
	 * Matches a target node against a pattern string.
	 * @param {PatternMatchableNode} targetNode - The node to match against.
	 * @param {string} patternStr - The code pattern (e.g., "int $x = 0;").
	 * @param {boolean} [deep=false] - Whether to search the subtree.
	 * @returns {CaptureResult | null} Captures object or null.
	 */
	match(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult | null;
	/**
	 * Matches all occurrences of a pattern.
	 * @returns {Array<CaptureResult>} Array of capture objects.
	 */
	matchAll(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult[];
	/**
	 * Prepares a pattern string for matching.
	 * @param {string} patternStr - The pattern string to prepare.
	 * @returns {{ patternRoot: SyntaxNode; constraints: ConstraintMap }} Object containing patternRoot and constraints.
	 */
	prepare(patternStr: string): {
		patternRoot: Parser.SyntaxNode;
		constraints: ConstraintMap;
	};
	/**
	 * Recursively searches for a match in the subtree.
	 */
	private findMatch;
	private findAllMatches;
	/**
	 * Compares two nodes structurally with wildcards.
	 * @param {PatternMatchableNode} target
	 * @param {SyntaxNode} pattern
	 * @param {CaptureResult} captures
	 * @param {ConstraintMap} constraints
	 * @returns {boolean}
	 */
	private structuralMatch;
	private getChildren;
	/**
	 * Pre-processes pattern string to extract constraints.
	 * @param {string} patternStr
	 * @returns {{cleanPattern: string, constraints: ConstraintMap}}
	 */
	private preprocessPattern;
	/**
	 * Parses a raw wildcard identifier into name and types.
	 * @param {string} rawId - The identifier text after $.
	 * @returns {{name: string; types: ConstraintSpec[]}}
	 */
	private parseWildcard;
}
export type CNodeTypes = 'translation_unit' | 'function_definition' | 'declaration' | 'identifier' | 'type_identifier' | 'field_identifier' | 'statement_identifier' | 'preproc_def' | 'preproc_include' | 'preproc_ifdef' | 'preproc_if' | 'preproc_else' | 'preproc_elif' | 'preproc_endif' | 'type_definition' | 'compound_statement' | 'pointer_declarator' | 'array_declarator' | 'parameter_declaration' | 'field_declaration' | 'struct_specifier' | 'union_specifier' | 'enum_specifier' | 'primitive_type' | 'parameter_list' | 'argument_list' | 'initializer_list' | 'init_declarator' | 'parenthesized_declarator' | 'enumerator_list' | 'field_declaration_list' | 'expression_statement' | 'if_statement' | 'for_statement' | 'while_statement' | 'do_statement' | 'return_statement' | 'break_statement' | 'continue_statement' | 'labeled_statement' | 'goto_statement' | 'switch_statement' | 'case_statement' | 'default_statement' | 'cast_expression' | 'unary_expression' | 'binary_expression' | 'conditional_expression' | 'assignment_expression' | 'comma_expression' | 'subscript_expression' | 'call_expression' | 'field_expression' | 'parenthesized_expression' | 'number_literal' | 'string_literal' | 'char_literal' | 'abstract_pointer_declarator' | 'type_descriptor' | 'storage_class_specifier' | 'type_qualifier' | 'pointer_declarator' | 'function_declarator' | 'array_declarator' | 'parenthesized_declarator' | 'struct_specifier' | 'union_specifier' | 'enum_specifier' | 'enumerator' | 'field_declaration' | 'parameter_declaration' | 'translation_unit' | 'attributed_statement' | (string & {});
/**
 * C-specific helper class.
 * @class
 * @extends UppHelpersBase
 */
export declare class UppHelpersC extends UppHelpersBase<CNodeTypes> {
	matcher: PatternMatcher;
	transformKey?: string;
	constructor(root: SourceNode<CNodeTypes>, registry: Registry, parentHelpers?: UppHelpersBase<any> | null);
	/**
	 * Matches a pattern against code.
	 * @param {SourceNode<any>} node - Target node.
	 * @param {string | string[]} src - Pattern source code.
	 * @param {function(any): any} [callback] - Callback with captures.
	 * @param {any} [options] - Match options.
	 * @returns {any} Result of callback or captures object (or null).
	 */
	match(node: SourceNode<any>, src: string | string[], callback?: (captures: Record<string, any>) => any, options?: {
		deep?: boolean;
	}): any;
	/**
	 * Matches all occurrences of a pattern.
	 * @param {SourceNode<any>} node - Target node.
	 * @param {string | string[]} src - Pattern source code.
	 * @param {function(any): any} [callback] - Optional callback.
	 * @param {any} [options] - Options.
	 * @returns {any[]} Matches.
	 */
	matchAll(node: SourceNode<any>, src: string | string[], callback?: (match: {
		node: SourceNode<CNodeTypes>;
		captures: Record<string, any>;
	}) => any, options?: {
		deep?: boolean;
	}): any[];
	/**
	 * Replaces all matches of a pattern.
	 * @param {SourceNode<CNodeTypes>} node - Scope.
	 * @param {string} src - Pattern.
	 * @param {function(any): string | null | undefined} callback - Replacement callback.
	 * @param {any} [options] - Options.
	 */
	matchReplace(node: SourceNode<CNodeTypes>, src: string, callback: (match: {
		node: SourceNode<CNodeTypes>;
		captures: Record<string, SourceNode<CNodeTypes>>;
	}) => string | null | undefined, options?: {
		deep?: boolean;
	}): void;
	/**
	 * Hoists content to the top of the file, skipping comments.
	 * @param {string} content - The content to hoist.
	 * @param {number} [_hoistIndex=0] - The index to hoist to.
	 */
	hoist(content: string, _hoistIndex?: number): void;
	/**
	 * extracts the C type string from a definition node.
	 * @param {SourceNode<CNodeTypes> | string | null} node - The definition identifier node or name.
	 * @returns {string} The C type string (e.g. "char *").
	 */
	getType(node: SourceNode<CNodeTypes> | string | null): string;
	/**
	 * Returns the number of array dimensions wrapping an identifier.
	 * @param {SourceNode<CNodeTypes>} defNode - The definition node.
	 * @returns {number} Array depth.
	 */
	getArrayDepth(defNode: SourceNode<CNodeTypes>): number;
	/**
	 * Determines the lexical scope node for a given identifier.
	 * @param {SourceNode<any>} node - The identifier node.
	 * @returns {SourceNode<CNodeTypes>|null} The scope node.
	 */
	getEnclosingScope(node: SourceNode<any>): SourceNode<CNodeTypes> | null;
	/**
	 * Extracts function signature details.
	 * @param {SourceNode<CNodeTypes>} fnNode - The function_definition node.
	 * @returns {any} Signature details.
	 */
	getFunctionSignature(fnNode: SourceNode<CNodeTypes>): any;
	/**
	 * Finds the definition for a node or name.
	 * @param {SourceNode<any>|string} target - The identifier node, a container node with a single identifier, or a scoping node (if name is provided).
	 * @param {string|any} [nameOrOptions] - The name to find (if target is a scope) or options object.
	 * @param {any} [options] - Resolution options { variable: true, tag: true }.
	 * @returns {SourceNode<CNodeTypes>|null} The declaration/definition node.
	 */
	findDefinitionOrNull(target: SourceNode<any> | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode<CNodeTypes> | null;
	/**
	 * Finds the definition for a node or name.
	 * @param {SourceNode<any>|string} target - The identifier node, a container node with a single identifier, or a scoping node (if name is provided).
	 * @param {string|any} [nameOrOptions] - The name to find (if target is a scope) or options object.
	 * @param {any} [options] - Resolution options { variable: true, tag: true }.
	 * @returns {SourceNode<CNodeTypes>} The declaration/definition node.
	 */
	findDefinition(target: SourceNode<any> | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode<CNodeTypes>;
	/**
	 * Finds references to a definition.
	 * @param {SourceNode<CNodeTypes>} node - The definition node.
	 * @returns {SourceNode<CNodeTypes>[]} The references.
	 */
	findReferences(node: SourceNode<CNodeTypes>): SourceNode<CNodeTypes>[];
	/**
	 * Transforms references to a definition intelligently.
	 * @param {SourceNode<CNodeTypes>} definitionNode - The definition node to find references for
	 * @param {function(SourceNode): string|null|undefined} callback - Transformation callback.
	 */
	withReferences(definitionNode: SourceNode<CNodeTypes>, callback: (n: SourceNode<CNodeTypes>) => string | null | undefined): void;
	/**
	 * Finds and transforms a definition node intelligently.
	 * @param {SourceNode<any>|string} target - The node or name to find definition for
	 * @param {function(SourceNode, UppHelpersC): string|null|undefined} callback - Transformation callback.
	 */
	withDefinition(target: SourceNode<any> | string, callback: (n: SourceNode<CNodeTypes>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Transforms nodes matching a pattern intelligently.
	 * @param {CNodeTypes} nodeType - The node type to match (e.g., 'call_expression')
	 * @param {function(SourceNode, UppHelpersC): boolean} matcher - Custom matcher function
	 * @param {function(SourceNode, UppHelpersC): string|null|undefined} callback - Transformation callback
	 */
	withPattern(nodeType: CNodeTypes, matcher: (node: SourceNode<CNodeTypes>, helpers: UppHelpersC) => boolean, callback: (node: SourceNode<CNodeTypes>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Transforms nodes matching a source fragment pattern.
	 * @param {SourceNode<any>} scope - The search scope.
	 * @param {string} pattern - The source fragment pattern.
	 * @param {function(any, UppHelpersC): (string|null|undefined)} callback - Transformation callback (receives captures).
	 */
	withMatch(scope: SourceNode<any>, pattern: string, callback: (captures: Record<string, SourceNode<CNodeTypes>>, helpers: UppHelpersC) => string | null | undefined): void;
}

export { };
