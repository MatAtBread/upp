==== examples/string_vla.c ===
/* A minimal C stdio/stdlib/string for upp to make it easy to
   see the output of the examples but permit compilation
*/
extern int puts(const char *s);
extern int printf(const char *format, ...);
extern int fputs(const char *s, void *stream);
extern void *malloc(unsigned long n);
extern void free(void *p);
extern char *strcpy(char *dest, const char *src);
extern char *strncat(char *dest, const char *src, unsigned long n);
extern int strcmp(const char *s1, const char *s2);
extern int snprintf(char *str, unsigned long size, const char *format, ...);
extern unsigned long strlen(const char *s);
extern void *stderr;
extern void *_stderr;

#include "managed-struct.h"
struct _ReferenceCount {
  int ref_count;
}
;
static inline void *_Managed_allocate(int size) {
  struct _ReferenceCount *p = malloc(size + sizeof(struct _ReferenceCount));
  p->ref_count = 1;
  printf("{%d} Allocate %d bytes\n", p->ref_count, size);
  return (void *)(p + 1);
}
static inline void *_Managed_retain(void *data) {
  struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
  p->ref_count++;
  //printf("{%d} Retain\n", p->ref_count);
  return data;
}
static inline void _Managed_release(void *__p) {
  void **_p = (void **)__p;
  void *data = *_p;
  if (data) {
    struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
    if (--p->ref_count <= 0) {
      printf("{%d} Free\n", p->ref_count);
      free(p);
      *_p = ((void *)0);
    }
  }
}
static inline void *_Managed_set(void *_dest, void *_src) {
  void **dest = _dest;
  if (*dest) { 
    struct _ReferenceCount *p = (struct _ReferenceCount *)(*dest) - 1;
    //printf("{%d} Set\n", p->ref_count);
    _Managed_release(dest);
  }
  return *dest = (_src ? _Managed_retain(_src) : ((void *)0));
}
static inline void *_Managed_move(void *_dest, void *_src) {
  void **dest = _dest;
  if (*dest) { 
    struct _ReferenceCount *p = (struct _ReferenceCount *)(*dest) - 1;
    _Managed_release(dest);
  }
  return *dest = _src;
}
static inline int _Managed_ref_count(void *data) {
    if (!data) return -1;
    return ((struct _ReferenceCount *)data - 1)->ref_count;
}
typedef struct {
    int len;
    char data[];
}* String;
#define _Managed_Sizeof_String(n) (sizeof(*(String)0) + sizeof(((String)0)->data[0]) * (n))


int _String_method_managed_reference_count(String p) {
    if (!p) return -1;
    return ((struct _ReferenceCount *)p - 1)->ref_count;
}

 
String create_string(const char *src) {
    int _n = strlen(src);
    String s = _Managed_allocate(_Managed_Sizeof_String(_n + 1));

 // Size includes null terminator
    s->len = _n;
    strcpy(s->data, src);
    _Managed_retain(s);_Managed_release(&s);return s;
}
int main() {
    String s = create_string("Hello, UPP Flexible Array!");


    int ok = (s->len == 26);
    ok &= (strcmp(s->data, "Hello, UPP Flexible Array!") == 0);
    printf("%s: %s (refs=%d)\n", ok ? "PASS" : "FAIL", s->data, _Managed_ref_count(s));
    _Managed_release(&s);return 0;
}

==== std/defer.h ===
#ifndef __UPP_STDLIB_DEFER_H__
#define __UPP_STDLIB_DEFER_H__


#endif

==== std/managed-struct.h ===
#include "defer.h"
#include "method.h"



==== std/method.h ===


==== RUN OUTPUT ===
{1} Allocate 31 bytes
PASS: Hello, UPP Flexible Array! (refs=1)
{0} Free

