==== examples/managed_move_test.c ===
/* A minimal C stdio/stdlib/string for upp to make it easy to
   see the output of the examples but permit compilation
*/
extern int puts(const char *s);
extern int printf(const char *format, ...);
extern int fputs(const char *s, void *stream);
extern void *malloc(unsigned long n);
extern void free(void *p);
extern char *strcpy(char *dest, const char *src);
extern char *strncat(char *dest, const char *src, unsigned long n);
extern int snprintf(char *str, unsigned long size, const char *format, ...);
extern unsigned long strlen(const char *s);
extern void *stderr;
extern void *_stderr;
#include "managed-struct.h"
struct _ReferenceCount {
  int ref_count;
}
;
static inline void *_Managed_allocate(int size) {
  struct _ReferenceCount *p = malloc(size + sizeof(struct _ReferenceCount));
  p->ref_count = 1;
  printf("{%d} Allocate %d bytes\n", p->ref_count, size);
  return (void *)(p + 1);
}
static inline void *_Managed_retain(void *data) {
  struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
  p->ref_count++;
  //printf("{%d} Retain\n", p->ref_count);
  return data;
}
static inline void _Managed_release(void *__p) {
  void **_p = (void **)__p;
  void *data = *_p;
  if (data) {
    struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
    if (--p->ref_count <= 0) {
      printf("{%d} Free\n", p->ref_count);
      free(p);
      *_p = ((void *)0);
    }
  }
}
static inline void *_Managed_set(void *_dest, void *_src) {
  void **dest = _dest;
  if (*dest) { 
    struct _ReferenceCount *p = (struct _ReferenceCount *)(*dest) - 1;
    //printf("{%d} Set\n", p->ref_count);
    _Managed_release(dest);
  }
  return *dest = (_src ? _Managed_retain(_src) : ((void *)0));
}
static inline void *_Managed_move(void *_dest, void *_src) {
  void **dest = _dest;
  if (*dest) { 
    struct _ReferenceCount *p = (struct _ReferenceCount *)(*dest) - 1;
    _Managed_release(dest);
  }
  return *dest = _src;
}
static inline int _Managed_ref_count(void *data) {
    if (!data) return -1;
    return ((struct _ReferenceCount *)data - 1)->ref_count;
}
typedef struct Foo_s* Foo;

int _Foo_method_managed_reference_count(Foo p) {
    if (!p) return -1;
    return ((struct _ReferenceCount *)p - 1)->ref_count;
}

 
struct Foo_s {
    int x;
};
Foo CreateFoo(int val) {
    Foo f = _Managed_allocate(sizeof(*f));


    f->x = val;
    _Managed_retain(f);_Managed_release(&f);return f;
}
int main() {
    Foo f1 = _Managed_allocate(sizeof(*f1));


    printf("--- Assignment from call ---\n");
    _Managed_move(&f1, CreateFoo(42)); // Should use _Managed_move
    printf("f1 val: %d, refcount: %d\n", f1->x, _Foo_method_managed_reference_count(f1));
    Foo f2 = _Managed_allocate(sizeof(*f2));


    printf("--- Assignment from variable ---\n");
    _Managed_set(&f2, f1); // Should use _Managed_set
    printf("f2 val: %d, refcount: %d\n", f2->x, _Foo_method_managed_reference_count(f2));
    if (_Foo_method_managed_reference_count(f1) == 2 && _Foo_method_managed_reference_count(f2) == 2) {
        printf("SUCCESS\n");
    } else {
        printf("FAILURE: refcounts are %d and %d\n", _Foo_method_managed_reference_count(f1), _Foo_method_managed_reference_count(f2));
    }
    _Managed_release(&f2);
_Managed_release(&f1);return 0;
}

==== std/defer.h ===
#ifndef __UPP_STDLIB_DEFER_H__
#define __UPP_STDLIB_DEFER_H__


#endif

==== std/managed-struct.h ===
#include "defer.h"
#include "method.h"



==== std/method.h ===


==== RUN OUTPUT ===
{1} Allocate 4 bytes
--- Assignment from call ---
{1} Allocate 4 bytes
{0} Free
f1 val: 42, refcount: 1
{1} Allocate 4 bytes
--- Assignment from variable ---
{0} Free
f2 val: 42, refcount: 2
SUCCESS
{0} Free

