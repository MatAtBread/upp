==== examples/ref-count.c ===
/* A minimal C stdio/stdlib/string for upp to make it easy to
   see the output of the examples but permit compilation
*/
extern int puts(const char *s);
extern int printf(const char *format, ...);
extern int fputs(const char *s, void *stream);
extern void *malloc(unsigned long n);
extern void free(void *p);
extern char *strcpy(char *dest, const char *src);
extern char *strncat(char *dest, const char *src, unsigned long n);
extern int snprintf(char *str, unsigned long size, const char *format, ...);
extern unsigned long strlen(const char *s);
extern void *stderr;
extern void *_stderr;

#include "method.h"
#include "managed-struct.h"
typedef struct Point_s {
    int x;
    int y;
} Point;
struct _ReferenceCount {
  int ref_count;
}
;
static inline void *_Managed_allocate(int size) {
  struct _ReferenceCount *p = malloc(size + sizeof(struct _ReferenceCount));
  p->ref_count = 1;
  printf("{%d} Allocate %d bytes\n", p->ref_count, size);
  return (void *)(p + 1);
}
static inline void *_Managed_retain(void *data) {
  struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
  p->ref_count++;
  printf("{%d} Retain\n", p->ref_count);
  return data;
}
static inline void _Managed_release(void *__p) {
  void **_p = (void **)__p;
  void *data = *_p;
  if (data) {
    struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
    p->ref_count--;
    printf("{%d} Release\n", p->ref_count);
    if (p->ref_count <= 0) {
      free(p);
      *_p = ((void *)0);
    }
  }
}
static inline void *_Managed_set(void *_dest, void *_src) {
  void **dest = _dest;
  if (*dest) { 
    struct _ReferenceCount *p = (struct _ReferenceCount *)(*dest) - 1;
    printf("{%d} Set\n", p->ref_count);
    _Managed_release(dest);
  }
  return *dest = (_src ? _Managed_retain(_src) : ((void *)0));
}
static inline int _Managed_ref_count(void *data) {
    if (!data) return -1;
    return ((struct _ReferenceCount *)data - 1)->ref_count;
}
typedef Point* PointRef;

int _PointRef_method_managed_reference_count(PointRef p) {
    if (!p) return -1;
    return ((struct _ReferenceCount *)p - 1)->ref_count;
}

 
 void _PointRef_method_print(PointRef p, const char *s) {
          _Managed_retain(p); 
            
          printf("%s {%d} (%d, %d)\n", s, _PointRef_method_managed_reference_count(p)
, p->x, p->y);
          _Managed_release(&p);}
void fn(PointRef p) {
          _Managed_retain(p); 
            
          _PointRef_method_print(p, "fn");
          _Managed_release(&p);}
PointRef origin() {
    PointRef p = _Managed_allocate(sizeof(*p));


    p->x = 0;
    p->y = 0;
    _Managed_retain(p);_Managed_release(&p);return p;
}
PointRef point(int x, int y) {
    PointRef p = _Managed_allocate(sizeof(*p));


    p->x = x;
    p->y = y;
    _Managed_retain(p);_Managed_release(&p);return p;
}
int main() {
    PointRef p = _Managed_allocate(sizeof(*p));


    PointRef q = origin();


    _Managed_set(&q, ((void *)0));
    printf("q %p\n", q);
    p->x = 10;
    p->y = 20;
    fn(p);
    p->x = 100;
    _PointRef_method_print(p, "p");
    _Managed_set(&q, origin());
    _Managed_set(&p, q);
    PointRef r = point(1, 2);


    _PointRef_method_print(r, "r");
    _PointRef_method_print(p, "p");
    PointRef s = ((void *)0);


    _Managed_set(&s, r);
    _PointRef_method_print(s, "s");
    _Managed_set(&s, p);
    _PointRef_method_print(s, "s");
    _Managed_release(&p);_Managed_release(&q);_Managed_release(&r);_Managed_release(&s);return 0;
}

==== std/defer.h ===
#ifndef __UPP_STDLIB_DEFER_H__
#define __UPP_STDLIB_DEFER_H__


#endif

==== std/managed-struct.h ===
#include "defer.h"
#include "method.h"



==== std/method.h ===


==== RUN OUTPUT ===
{1} Allocate 8 bytes
{1} Allocate 8 bytes
{2} Retain
{1} Release
{1} Set
{0} Release
q 0x0
{2} Retain
{3} Retain
fn {3} (10, 20)
{2} Release
{1} Release
{2} Retain
p {2} (100, 20)
{1} Release
{1} Allocate 8 bytes
{2} Retain
{1} Release
{2} Retain
{1} Set
{0} Release
{3} Retain
{1} Allocate 8 bytes
{2} Retain
{1} Release
{2} Retain
r {2} (1, 2)
{1} Release
{4} Retain
p {4} (0, 0)
{3} Release
{2} Retain
{3} Retain
s {3} (1, 2)
{2} Release
{2} Set
{1} Release
{4} Retain
{5} Retain
s {5} (0, 0)
{4} Release
{3} Release
{2} Release
{0} Release
{1} Release

