==== examples/box_ref_test.c ===
/* A minimal C stdio/stdlib/string for upp to make it easy to
   see the output of the examples but permit compilation
*/
extern int puts(const char *s);
extern int printf(const char *format, ...);
extern int fputs(const char *s, void *stream);
extern void *malloc(unsigned long n);
extern void free(void *p);
extern char *strcpy(char *dest, const char *src);
extern char *strncat(char *dest, const char *src, unsigned long n);
extern int strcmp(const char *s1, const char *s2);
extern int snprintf(char *str, unsigned long size, const char *format, ...);
extern unsigned long strlen(const char *s);
extern void *stderr;
extern void *_stderr;
#include "box_ref_test.h"
int main() {
    printf("--- BoxRef Test ---\n");
    BoxRef b = create_box(42);

    BoxRef c = create_box(100);

    printf("Box c value: %d, refs: %d\n", c->value, _BoxRef_method_managed_reference_count(c));
    printf("Box b value: %d, refs: %d\n", b->value, _BoxRef_method_managed_reference_count(b));
    printf("--- Assignment b = c ---\n");
    _Managed_set(&b, c);
    printf("Box c value: %d, refs: %d\n", c->value, _BoxRef_method_managed_reference_count(c));
    printf("Box b value: %d, refs: %d\n", b->value, _BoxRef_method_managed_reference_count(b));
    if (b->value == 100 && _BoxRef_method_managed_reference_count(b) == 2) {
        printf("SUCCESS\n");
    } else {
        printf("FAILURE: b->value=%d, refs=%d\n", b->value, _BoxRef_method_managed_reference_count(b));
    }
    _Managed_release(&c);
_Managed_release(&b);return 0;
}

==== examples/box_ref_test.h ===
#include "managed-struct.h"

struct _ReferenceCount {
  int ref_count;
}
;
static inline void *_Managed_allocate(int size) {
  struct _ReferenceCount *p = malloc(size + sizeof(struct _ReferenceCount));
  p->ref_count = 1;
  printf("{%d} Allocate %d bytes\n", p->ref_count, size);
  return (void *)(p + 1);
}
static inline void *_Managed_retain(void *data) {
  struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
  p->ref_count++;
  //printf("{%d} Retain\n", p->ref_count);
  return data;
}
static inline void _Managed_release(void *__p) {
  void **_p = (void **)__p;
  void *data = *_p;
  if (data) {
    struct _ReferenceCount *p = (struct _ReferenceCount *)data - 1;
    if (--p->ref_count <= 0) {
      printf("{%d} Free\n", p->ref_count);
      free(p);
      *_p = ((void *)0);
    }
  }
}
static inline void *_Managed_set(void *_dest, void *_src) {
  void **dest = _dest;
  if (*dest) { 
    struct _ReferenceCount *p = (struct _ReferenceCount *)(*dest) - 1;
    //printf("{%d} Set\n", p->ref_count);
    _Managed_release(dest);
  }
  return *dest = (_src ? _Managed_retain(_src) : ((void *)0));
}
static inline void *_Managed_move(void *_dest, void *_src) {
  void **dest = _dest;
  if (*dest) { 
    struct _ReferenceCount *p = (struct _ReferenceCount *)(*dest) - 1;
    _Managed_release(dest);
  }
  return *dest = _src;
}
static inline int _Managed_ref_count(void *data) {
    if (!data) return -1;
    return ((struct _ReferenceCount *)data - 1)->ref_count;
}
typedef struct Box* BoxRef;
#define _Managed_Sizeof_BoxRef(n) (sizeof(*(BoxRef)0) * (n))


int _BoxRef_method_managed_reference_count(BoxRef p) {
    if (!p) return -1;
    return ((struct _ReferenceCount *)p - 1)->ref_count;
}

 
struct Box {
    int value;
};

BoxRef create_box(int val) {
    BoxRef b = _Managed_allocate(_Managed_Sizeof_BoxRef(1));


    b->value = val;
    _Managed_retain(b);_Managed_release(&b);return b;
}

==== std/defer.h ===
#ifndef __UPP_STDLIB_DEFER_H__
#define __UPP_STDLIB_DEFER_H__


#endif

==== std/managed-struct.h ===
#include "defer.h"
#include "method.h"



==== std/method.h ===


==== RUN OUTPUT ===
--- BoxRef Test ---
{1} Allocate 4 bytes
{1} Allocate 4 bytes
Box c value: 100, refs: 1
Box b value: 42, refs: 1
--- Assignment b = c ---
{0} Free
Box c value: 100, refs: 2
Box b value: 100, refs: 2
SUCCESS
{0} Free

