// Generated by scripts/generate_vscode_dts.js

declare namespace Parser {
    type Tree = any;
    type SyntaxNode = any;
}


declare namespace upp_types {

// Generated by dts-bundle-generator v9.5.1


export interface MaterializeOptions {
	isAuthoritative: boolean;
}
export interface PatternMatchableNode {
	type: string;
	text: string;
	childCount: number;
	child(index: number): PatternMatchableNode | null;
}
/**
 * Branded type for Tree-sitter Language objects.
 * Prevents accidental assignment of generic objects to language fields.
 */
export type Language = any & {
	readonly __brand: unique symbol;
};
/**
 * Common return type for macro evaluations and transformations.
 */
export type MacroResult<T extends string = string> = SourceNode<T> | SourceNode<any>[] | SourceTree<any> | string | null | undefined;
/**
 * Type alias for any SourceNode.
 */
export type AnySourceNode = SourceNode<any>;
/**
 * Type alias for any SourceTree.
 */
export type AnySourceTree = SourceTree<any>;
/**
 * Types that can be interpolated into UPP code fragments.
 */
export type InterpolationValue = string | number | boolean | AnySourceNode | AnySourceTree | AnySourceNode[] | null | undefined;
export class SourceTree<NodeTypes extends string = string> {
	source: string;
	language: Language;
	parser: any;
	tree: any;
	nodeCache: Map<number | string, SourceNode<NodeTypes>>;
	root: SourceNode<NodeTypes>;
	onMutation: (() => void) | null;
	/**
	 * @param {string} source Initial source code text.
	 * @param {Language} language Tree-sitter Language object.
	 */
	constructor(source: string, language: Language);
	/**
	 * Internal method to get or create a SourceNode wrapper for a Tree-sitter node.
	 * @param {SyntaxNode | null} tsNode The Tree-sitter node to wrap.
	 * @param {SourceNode | null} [parent] The parent SourceNode, if any.
	 * @param {string | null} [fieldName] The field name for this node in the parent.
	 * @returns {SourceNode|null}
	 */
	wrap<T extends NodeTypes>(tsNode: any | null, parent?: SourceNode<NodeTypes> | null, fieldName?: string | null): SourceNode<T> | null;
	/**
	 * Apply a specialized splice to the source string and update tracking for all active nodes.
	 * @param {number} start The start index of the edit.
	 * @param {number} end The end index of the edit.
	 * @param {string} newText The replacement text.
	 */
	edit(start: number, end: number, newText: string): void;
	/** @returns {number} */
	get startIndex(): number;
	/** @returns {number} */
	get endIndex(): number;
	/** @returns {string} */
	get type(): string;
	/** @returns {SourceNode<any>[]} */
	get children(): SourceNode<NodeTypes>[];
	/** @returns {string} */
	get text(): string;
	/** @param {string} val */
	set text(val: string);
	/**
	 * Creates a SourceNode from a code fragment.
	 * Tries to parse as valid code; if it fails, wraps in a dummy function to parse statements/expressions.
	 * @param {string | SourceNode<any> | SourceTree<any>} code The text fragment to parse.
	 * @param {Language} language Tree-sitter language object.
	 * @returns {SourceNode<NodeTypes>}
	 */
	static fragment<NodeTypes extends string = string>(code: string | SourceNode<any> | SourceTree<any>, language: Language): SourceNode<NodeTypes>;
	/**
	 * Serializes the tree to JSON, avoiding circular references.
	 * @returns {Object}
	 */
	toJSON(): {
		source: string;
		root: any;
	};
	/**
	 * Merges current tree's nodes into another target SourceTree.
	 * @param {SourceTree} targetTree The tree to merge into.
	 * @param {number} offset The offset to apply to all migrated nodes.
	 */
	mergeInto(targetTree: SourceTree<NodeTypes>, offset: number): void;
}
export class SourceNode<T extends string = string> {
	tree: SourceTree<any>;
	id: number | string;
	type: T;
	startIndex: number;
	endIndex: number;
	children: SourceNode<any>[];
	parent: SourceNode<any> | null;
	fieldName: string | null;
	data: Record<string, unknown>;
	_capturedText?: string;
	_snapshotSearchable?: string;
	_detachedParent?: SourceNode<any> | null;
	_detachedIndex?: number;
	/**
	 * @param {SourceTree<any>} tree The tree this node belongs to.
	 * @param {SyntaxNode} tsNode The Tree-sitter node to wrap.
	 * @param {SourceNode<any> | null} [parent] The parent SourceNode, if any.
	 * @param {string | null} [fieldName] The field name for this node in the parent.
	 */
	constructor(tree: SourceTree<any>, tsNode: any, parent?: SourceNode<any> | null, fieldName?: string | null);
	/** @returns {boolean} */
	get isNamed(): boolean;
	/** @returns {boolean} */
	get isValid(): boolean;
	/** @returns {SourceNode<any>|null} */
	get nextNamedSibling(): SourceNode<any> | null;
	/** @returns {SourceNode<any>|null} */
	get prevNamedSibling(): SourceNode<any> | null;
	/** @returns {number} */
	get namedChildCount(): number;
	/**
	 * @param {number} idx
	 * @returns {SourceNode<any>|null}
	 */
	namedChild(idx: number): SourceNode<any> | null;
	/** @returns {SourceNode<any>|null} */
	get firstNamedChild(): SourceNode<any> | null;
	toString(): string;
	/** @returns {string} */
	get text(): string;
	/**
	 * Returns the name to use for symbol resolution.
	 * Prioritizes _capturedText to allow resolution by original name after a rename.
	 * @returns {string}
	 */
	get searchableText(): string;
	/** @param {string} value */
	set text(value: string);
	/** @returns {number} */
	get childCount(): number;
	/**
	 * Returns an object mapping named children to their nodes.
	 * Proxied for concise access (e.g., node.named.fieldName).
	 * @returns {Record<string, SourceNode<any> | undefined>}
	 */
	get named(): Record<string, SourceNode<any> | undefined>;
	/**
	 * @returns {Object}
	 */
	toJSON(): Object;
	/**
	 * @param {number} idx
	 * @returns {SourceNode<any>}
	 */
	child(idx: number): SourceNode<any>;
	/**
	 * Internal method called by SourceTree when a global edit happens.
	 * @param {number} editStart The start index of the edit.
	 * @param {number} editEnd The end index of the edit.
	 * @param {number} delta Offset change duration.
	 */
	handleEdit(editStart: number, editEnd: number, delta: number): void;
	/**
	 * Removes the node from the tree and returns the removed sub-tree.
	 * @returns {SourceTree<any>}
	 */
	remove(): SourceTree<any>;
	/**
	 * Recursively invalidates this node and its children,
	 * removing them from the tree cache.
	 * @private
	 */
	_invalidateRecursively(): void;
	/**
	 * Replaces this node with another node or text.
	 * @param {string | SourceNode<any> | SourceNode<any>[] | SourceTree<any>} content The node or text to replace with.
	 * @param {boolean} [morphIdentity=true] Whether the current node should morph into the replacement node, preserving the current node's AST reference.
	 * @returns {SourceNode<any> | SourceNode<any>[] | null}
	 */
	replaceWith(content: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any>, morphIdentity?: boolean): SourceNode<any> | SourceNode<any>[] | null;
	/**
	 * Inserts a node or text after this node.
	 * @param {SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>} content The node or text to insert.
	 * @returns {SourceNode<any> | SourceNode<any>[]}
	 */
	insertAfter(content: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>): SourceNode<any> | SourceNode<any>[];
	/** @returns {SourceNode<any>[]} All children (including unnamed like '{', ';', etc.) */
	get allChildren(): SourceNode<any>[];
	/**
	 * Inserts a node or text before this node.
	 * @param {SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>} content The node or text to insert.
	 * @returns {SourceNode<any> | SourceNode<any>[]}
	 */
	insertBefore(content: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>): SourceNode<any> | SourceNode<any>[];
	/**
	 * Inserts a node or text at a specific child index (including unnamed children).
	 * @param {number} idx The child index to insert at.
	 * @param {SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>} content The node or text to insert.
	 * @returns {SourceNode<any> | SourceNode<any>[]}
	 */
	insertAt(idx: number, content: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>): SourceNode<any> | SourceNode<any>[];
	/**
	 * Internal method to attach a new node (or text/tree/array) to this node's tree at a specific offset.
	 * @param {SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>} newNode - The content to attach.
	 * @param {number} insertionOffset - The absolute start index in the tree.
	 * @returns {SourceNode<any> | SourceNode<any>[] | null}
	 */
	_attachNewNode(newNode: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>, insertionOffset: number): SourceNode<any> | SourceNode<any>[] | null;
	/**
	 * Finds nodes by type or predicate using simple recursive iteration.
	 * Unlike match(), find() is based on node types, not structural code patterns.
	 * Use this for simple type-based searches (e.g. finding all 'return_statement's).
	 *
	 * @param {K | function(SourceNode<any>): boolean} predicate - Type name or filter function.
	 * @returns {SourceNode<K>[]}
	 */
	find<K extends string>(predicate: K | ((n: SourceNode<any>) => boolean)): SourceNode<K>[];
	/**
	 * Finds the smallest descendant that contains the given index range.
	 * @param {number} start - Start index.
	 * @param {number} end - End index.
	 * @returns {SourceNode<any>}
	 */
	descendantForIndex(start: number, end: number): SourceNode<any>;
	/**
	 * Appends a node or text as a child of this node.
	 * Requires the node to already have children to use as anchors.
	 * @param {SourceNode<any> | SourceTree<any> | string} newNode - The node or text to append.
	 * @returns {SourceNode<any> | SourceNode<any>[]}
	 */
	append(newNode: SourceNode<any> | SourceTree<any> | string): SourceNode<any> | SourceNode<any>[];
	/**
	 * Creates a deep clone of the node by parsing its text as a new fragment.
	 * @returns {SourceNode<T>} A new node instance with the same content but fresh identity.
	 */
	clone(): SourceNode<T>;
}
export interface DiagnosticsConfig {
	suppress?: string[];
}
export class DiagnosticsManager {
	private suppressed;
	/**
	 * @param {DiagnosticsConfig} [config={}] - Configuration object with suppression list.
	 */
	constructor(config?: DiagnosticsConfig);
	/**
	 * Reports a warning if not suppressed.
	 * @param {string | number} code - The diagnostic code (e.g., UPP001).
	 * @param {string} message - The warning message.
	 * @param {string} filePath - File where warning occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code for context.
	 */
	reportWarning(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null): void;
	/**
	 * Reports an error and optionally exits.
	 * @param {string | number} code - The diagnostic code.
	 * @param {string} message - The error message.
	 * @param {string} filePath - File where error occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code.
	 * @param {boolean} [fatal=true] - Whether to exit the process.
	 */
	reportError(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null, fatal?: boolean): void;
	/**
	 * Helper to calculate line and column from character index.
	 * @param {string} source - Source code.
	 * @param {number} index - Character index.
	 * @returns {{line: number, col: number}} 1-indexed line and col.
	 */
	static getLineCol(source: string, index: number): {
		line: number;
		col: number;
	};
}
export interface CacheData {
	macros: Macro[];
	transformRules: TransformRule[];
	output: string;
	shouldMaterialize: boolean;
	isAuthoritative: boolean;
}
export class DependencyCache {
	private cache;
	constructor();
	/**
	 * Checks if a file is in the cache.
	 * @param {string} filePath - Absolute path.
	 * @returns {boolean}
	 */
	has(filePath: string): boolean;
	/**
	 * Gets data for a file.
	 * @param {string} filePath
	 * @returns {CacheData | undefined}
	 */
	get(filePath: string): CacheData | undefined;
	/**
	 * Sets data for a file.
	 * @param {string} filePath
	 * @param {CacheData} data
	 */
	set(filePath: string, data: CacheData): void;
}
export interface Macro {
	name: string;
	params: string[];
	body: string;
	language: string;
	origin: string;
	startIndex: number;
}
export interface TransformRule<T extends string = string> {
	active: boolean;
	matcher: (node: SourceNode<T>, helpers: UppHelpersBase<any>) => boolean;
	callback: (node: SourceNode<T>, helpers: UppHelpersBase<any>) => MacroResult;
}
export interface PendingRule<T extends string = string> {
	id: number;
	contextNode: SourceNode<any>;
	matcher: (node: SourceNode<T>, helpers: UppHelpersBase<any>) => boolean;
	callback: (node: SourceNode<T>, helpers: UppHelpersBase<any>) => MacroResult;
}
export interface Invocation {
	name: string;
	args: string[];
	startIndex: number;
	endIndex: number;
	line?: number;
	col?: number;
	invocationNode?: SourceNode<any>;
}
export interface RegistryConfig {
	onMaterialize?: (outputPath: string, content: string, options: MaterializeOptions) => void;
	filePath?: string;
	stdPath?: string;
	cache?: DependencyCache;
	diagnostics?: DiagnosticsManager;
	suppress?: string[];
	comments?: boolean;
}
export interface RegistryContext {
	source: string;
	tree: SourceTree<any>;
	originPath: string;
	invocations: Invocation[];
	helpers: UppHelpersBase<any> | null;
	transformed: Set<SourceNode<any>>;
	transformStack: Set<SourceNode<any>>;
	appliedRules: WeakMap<SourceNode<any>, Set<number>>;
	definitionCache: Map<string | number, SourceNode<any> | null>;
	scopeCache: Map<string | number, SourceNode<any>[]>;
	enclosingScopeCache: Map<string | number, SourceNode<any> | null>;
	mutated?: boolean;
}
export type TreeSitterLang = Language;
export class Registry {
	config: RegistryConfig;
	parentRegistry: Registry | null;
	depth: number;
	filePath: string;
	diagnostics: DiagnosticsManager;
	language: TreeSitterLang;
	helpers: UppHelpersBase<any> | null;
	parentHelpers: UppHelpersBase<any> | null;
	parentTree: SourceTree<any> | null;
	materializedFiles: Set<string>;
	isAuthoritative: boolean;
	macros: Map<string, Macro>;
	parser: any;
	idCounter: number;
	stdPath: string | null;
	loadedDependencies: Map<string, string>;
	shouldMaterializeDependency: boolean;
	transformRules: TransformRule<any>[];
	pendingRules: PendingRule<any>[];
	ruleIdCounter: number;
	isExecutingDeferred: boolean;
	onMaterialize: ((outputPath: string, content: string, options: {
		isAuthoritative: boolean;
	}) => void) | null;
	mainContext: RegistryContext | null;
	UppHelpersC: typeof UppHelpersC;
	source?: string;
	tree?: SourceTree<any>;
	activeTransformNode?: SourceNode<any> | null;
	originPath?: string;
	constructor(config?: RegistryConfig, parentRegistry?: Registry | null);
	/**
	 * Registers a context-bound rule that will be evaluated whenever new nodes are inserted into the AST.
	 * @param {PendingRule<any>} rule - The rule to register.
	 */
	registerPendingRule(rule: Omit<PendingRule<any>, "id">): number;
	/**
	 * Registers a new macro in the registry.
	 * @param {string} name - Name of the macro.
	 * @param {string[]} params - Parameter names.
	 * @param {string} body - Macro body (JS or C).
	 * @param {string} [language='js'] - Macro implementation language.
	 * @param {string} [origin='unknown'] - Origin file or package.
	 * @param {number} [startIndex=0] - Start index in the origin file.
	 */
	registerMacro(name: string, params: string[], body: string, language?: string, origin?: string, startIndex?: number): void;
	/**
	 * Retrieves a macro by name, searching parent registries if necessary.
	 * @param {string} name - The name of the macro.
	 * @returns {Macro | undefined} The macro definition or undefined.
	 */
	getMacro(name: string): Macro | undefined;
	/**
	 * Registers a global transformation rule.
	 * @param {TransformRule<any> | function(SourceNode<any>, any): any} rule - The rule object or callback.
	 */
	registerTransformRule(rule: TransformRule<any> | ((node: SourceNode<any>, helpers: any) => SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined)): void;
	loadDependency(file: string, originPath?: string, parentHelpers?: UppHelpersC | null): void;
	generateRuleId(): string;
	/**
	 * Transforms a source string by evaluating macros and applying rules.
	 * @param {string} source - The UPP source code.
	 * @param {string} [originPath='unknown'] - Path for diagnostic reporting.
	 * @param {UppHelpersC | null} [parentHelpers=null] - Parent helper context.
	 * @returns {string} The transformed C code.
	 */
	transform(source: string, originPath?: string, parentHelpers?: UppHelpersC | null): string;
	/**
	 * Internal helper to mark the current transformation context as mutated.
	 */
	markMutated(): void;
	/**
	 * Recursively evaluates pending rules (fixed-point iteration).
	 * This is used for cross-cutting transformations after the initial macro walk.
	 * @private
	 */
	private evaluatePendingRules;
	/**
	 * Recursively transforms an AST node by evaluating macros and markers.
	 * @param {SourceNode<any>} node - The node to transform.
	 * @param {UppHelpersBase<any>} helpers - Helper class instance.
	 * @param {RegistryContext} context - Current transformation context.
	 * @param {boolean} [force=false] - Whether to bypass the 'transformed' optimization check.
	 */
	transformNode(node: SourceNode<any>, helpers: UppHelpersBase<any>, context: RegistryContext, force?: boolean): void;
	/**
	 * Evaluates a macro invocation and returns the resulting content.
	 * @param {Invocation} invocation - The macro invocation details.
	 * @param {string} source - The context source.
	 * @param {any} helpers - Helper class instance.
	 * @param {string} filePath - Current file path.
	 * @returns {SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined}
	 */
	evaluateMacro(invocation: Invocation, source: string, helpers: UppHelpersBase<any>, filePath: string): MacroResult;
	createMacroFunction(macro: Macro): Function;
	/**
	 * Prepares source code by identifying macro invocations and masking them.
	 * @param {string} source - The raw source code.
	 * @param {string} originPath - Path for diagnostics.
	 * @returns {{ cleanSource: string, invocations: Invocation[] }} Masked source and invocations.
	 */
	prepareSource(source: string, originPath: string): {
		cleanSource: string;
		invocations: Invocation[];
	};
	extractBody(source: string, startOffset: number): string;
	findInvocations(source: string, tree?: any | null): Invocation[];
	absorbInvocation(text: string, startIndex: number): {
		name: string;
		args: string[];
	} | null;
	isInsideInvocation(_start: number, _end: number): boolean;
}
export interface ConstraintSpec {
	type: string;
	not: boolean;
}
export type ConstraintMap = Map<string, ConstraintSpec[]>;
export interface CaptureResult {
	node?: PatternMatchableNode;
	[key: string]: any;
}
export class PatternMatcher {
	private parseFn;
	private cache;
	private language;
	/**
	 * @param {function(string): Tree} parseFn - Function to parse a code fragment.
	 * @param {any} language - The language object.
	 */
	constructor(parseFn: (code: string) => any, language: any);
	/**
	 * Matches a target node against a pattern string.
	 * @param {PatternMatchableNode} targetNode - The node to match against.
	 * @param {string} patternStr - The code pattern (e.g., "int $x = 0;").
	 * @param {boolean} [deep=false] - Whether to search the subtree.
	 * @returns {CaptureResult | null} Captures object or null.
	 */
	match(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult | null;
	/**
	 * Matches all occurrences of a pattern.
	 * @returns {Array<CaptureResult>} Array of capture objects.
	 */
	matchAll(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult[];
	/**
	 * Prepares a pattern string for matching.
	 * @param {string} patternStr - The pattern string to prepare.
	 * @returns {{ patternRoot: SyntaxNode; constraints: ConstraintMap }} Object containing patternRoot and constraints.
	 */
	prepare(patternStr: string): {
		patternRoot: any;
		constraints: ConstraintMap;
	};
	/**
	 * Recursively searches for a match in the subtree.
	 */
	private findMatch;
	private findAllMatches;
	/**
	 * Compares two nodes structurally with wildcards.
	 * @param {PatternMatchableNode} target
	 * @param {SyntaxNode} pattern
	 * @param {CaptureResult} captures
	 * @param {ConstraintMap} constraints
	 * @returns {boolean}
	 */
	private structuralMatch;
	private matchChildren;
	private getWildcard;
	private getChildren;
	/**
	 * Pre-processes pattern string to extract constraints.
	 * @param {string} patternStr
	 * @returns {{cleanPattern: string, constraints: ConstraintMap}}
	 */
	private preprocessPattern;
	/**
	 * Parses a raw wildcard identifier into name and types.
	 * @param {string} rawId - The identifier text after $.
	 * @returns {{name: string; types: ConstraintSpec[]}}
	 */
	private parseWildcard;
}
export class UppHelpersBase<LanguageNodeTypes extends string> {
	root: SourceNode<LanguageNodeTypes> | null;
	registry: Registry;
	matcher: PatternMatcher;
	_parentHelpers: UppHelpersBase<LanguageNodeTypes> | null;
	contextNode: SourceNode<LanguageNodeTypes> | null;
	invocation: Invocation | null;
	lastConsumedNode: SourceNode<LanguageNodeTypes> | null;
	isDeferred: boolean;
	currentInvocations: Invocation[];
	consumedIds: Set<number | string>;
	context: RegistryContext | null;
	parentTree: SourceNode<any> | null;
	stdPath: string | null;
	lastConsumedIndex?: number;
	parentRegistry?: {
		invocations: Invocation[];
		sourceCode: string;
		helpers: UppHelpersBase<LanguageNodeTypes>;
	};
	topLevelInvocation?: Invocation | null;
	get parentHelpers(): UppHelpersBase<LanguageNodeTypes> | null;
	set parentHelpers(v: UppHelpersBase<LanguageNodeTypes> | null);
	get isAuthoritative(): boolean;
	set isAuthoritative(v: boolean);
	constructor(root: SourceNode<LanguageNodeTypes> | null, registry: Registry, parentHelpers?: UppHelpersBase<LanguageNodeTypes> | null);
	code(strings: TemplateStringsArray, ...values: InterpolationValue[]): SourceNode<LanguageNodeTypes>;
	/**
	 * Determines how an array should be expanded based on its parent context.
	 * @param {any[]} values The values to expand.
	 * @param {string} parentType The tree-sitter node type of the parent.
	 * @returns {any[]} The expanded list of nodes/text.
	 */
	protected getArrayExpansion(values: InterpolationValue[], parentType: string): InterpolationValue[];
	/**
	 * Executes a callback within the context of the root node.
	 * @param {function(SourceNode<LanguageNodeTypes>, UppHelpersBase<LanguageNodeTypes>): any} callback - The callback to execute.
	 * @returns {string} Always empty string (transformations happen via markers).
	 */
	withRoot(callback: (root: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): void;
	/**
	 * Executes a callback within the context of the current scope.
	 * @param {function(SourceNode<LanguageNodeTypes>, UppHelpersBase<LanguageNodeTypes>): any} callback - The callback to execute.
	 * @returns {string} Always empty string.
	 */
	withScope(callback: (scope: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): void;
	/**
	 * Replaces a node with new content.
	 * @param {SourceNode<LanguageNodeTypes>} n - The node to replace.
	 * @param {string | SourceNode<any> | SourceNode<any>[] | SourceTree<any> | null} newContent - The replacement content.
	 * @returns {SourceNode<LanguageNodeTypes> | SourceNode<LanguageNodeTypes>[] | null} The new node(s) or null.
	 */
	replace(n: SourceNode<LanguageNodeTypes>, newContent: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any> | null): SourceNode<LanguageNodeTypes> | SourceNode<LanguageNodeTypes>[] | null;
	/**
	 * Finds the root node of the current context or the main tree.
	 * @returns {SourceNode<LanguageNodeTypes> | null} The root node.
	 */
	findRoot(): SourceNode<LanguageNodeTypes> | null;
	/**
	 * Attaches a marker to a node for late-bound transformation.
	 * @param {SourceNode<LanguageNodeTypes> | null} node - The target node.
	 * @param {function(SourceNode<LanguageNodeTypes>, UppHelpersBase<LanguageNodeTypes>): any} callback - The transformation callback.
	 * @returns {string} Always empty string.
	 */
	withNode(node: SourceNode<LanguageNodeTypes> | null, callback: (target: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): void;
	/**
	* Performs a one-off structural match against a specific node.
	* Unlike find(), match() uses code patterns and can extract sub-nodes into captures.
	* Use this for immediate inspection or to "peek" into a node's structure.
	*
	* @param {AnySourceNode} node - Target node to match against.
	* @param {string | string[]} src - Pattern(s) to match. Can include $wildcards.
	* @param {function(captures: Record<string, AnySourceNode>): any} [callback] - Function called with captures if match succeeds.
	* @param {{ deep?: boolean }} [options] - Match options (e.g., deep search).
	* @returns {any} Result of callback, captures object, or null.
	*/
	match(node: AnySourceNode, src: string | string[], callback?: (captures: Record<string, AnySourceNode>) => any, options?: {
		deep?: boolean;
	}): any;
	/**
	 * Finds all structural matches of a pattern within a scope.
	 * Unlike find(), this matches against complex code templates rather than just node types.
	 *
	 * @param {AnySourceNode} node - Search scope.
	 * @param {string | string[]} src - Pattern(s) to match.
	 * @param {{ deep?: boolean }} [options] - Options (deep search is often enabled by default).
	 * @returns {{ node: SourceNode<LanguageNodeTypes>, captures: Record<string, AnySourceNode> }[]} List of matches (node + captures).
	 */
	matchAll(node: AnySourceNode, src: string | string[], options?: {
		deep?: boolean;
	}): {
		node: SourceNode<LanguageNodeTypes>;
		captures: Record<string, AnySourceNode>;
	}[];
	/**
	* Synchronously replaces all matches of a pattern within a scope.
	* Replacements happen immediately during macro execution.
	* Contrast with withMatch(), which defers transformations until later.
	*
	* @param {SourceNode<LanguageNodeTypes>} node - Search scope.
	* @param {string} src - Pattern to match.
	* @param {function(match: { node: SourceNode<LanguageNodeTypes>, captures: Record<string, SourceNode<LanguageNodeTypes>> }): string | null | undefined} callback - Returns replacement text or node.
	* @param {{ deep?: boolean }} [options] - Options.
	*/
	matchReplace(node: SourceNode<LanguageNodeTypes>, src: string, callback: (match: {
		node: SourceNode<LanguageNodeTypes>;
		captures: Record<string, SourceNode<LanguageNodeTypes>>;
	}) => string | null | undefined, options?: {
		deep?: boolean;
	}): void;
	/**
	* Registers a marker for deferred transformation of nodes matching a pattern.
	* The callback is executed later by the registry, ensuring the node is in its
	* final state after other macros have executed. This is the safest way to
	* perform cross-cutting or global transformations.
	*
	* @param {AnySourceNode} scope - The search scope.
	* @param {string} pattern - The source fragment pattern.
	* @param {function(Record<string, AnySourceNode>, UppHelpersBase<LanguageNodeTypes>, AnySourceNode): MacroResult} callback - Deferred transformation callback.
	*/
	withMatch(scope: AnySourceNode, pattern: string | string[], callback: (captures: Record<string, AnySourceNode>, helpers: UppHelpersBase<LanguageNodeTypes>, node: AnySourceNode) => MacroResult): void;
	/**
	* Registers a marker for intelligent, pattern-based transformation of a specific node type.
	* Unlike withMatch(), which uses source code fragments, withPattern() matches against
	* specific AST node types and uses a custom matcher function for filtering.
	*
	* @param {LanguageNodeTypes} nodeType - The node type to match (e.g., 'call_expression').
	* @param {function(SourceNode<LanguageNodeTypes>, UppHelpersBase<LanguageNodeTypes>): boolean} matcher - Custom filter function.
	* @param {function(SourceNode<LanguageNodeTypes>, UppHelpersBase<LanguageNodeTypes>): MacroResult} callback - Deferred transformation callback.
	*/
	withPattern(nodeType: LanguageNodeTypes, matcher: (node: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => boolean, callback: (node: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => MacroResult): void;
	/**
	 * Finds macro invocations in the tree.
	 * @param {string} macroName - Name of the macro (without @).
	 * @param {SourceNode<LanguageNodeTypes>} [node] - Search scope.
	 * @returns {Invocation[]} List of invocations found.
	 */
	findInvocations(macroName: string, node?: SourceNode<LanguageNodeTypes> | null): Invocation[];
	/**
	 * Loads a dependency file into the registry.
	 * @param {string} file - The file path to load.
	 */
	loadDependency(file: string): void;
	/**
	 * Finds the next logical node after the macro invocation.
	 * @private
	 */
	_getNextNode(expectedTypes?: string[] | null): SourceNode<LanguageNodeTypes> | null;
	/**
	 * Retrieves the next node without removing it from the tree.
	 * @param {K|K[] | null} [types]
	 * @returns {SourceNode<K>|null}
	 */
	nextNode<K extends LanguageNodeTypes>(types?: K | K[] | null): SourceNode<K> | null;
	/**
	 * Consumes the next logical node after the macro invocation.
	 * @param {K | K[] | { type?: K | K[], message?: string, validate?: (n: SourceNode<LanguageNodeTypes>) => boolean }} [expectedTypeOrOptions] - Expected node type(s) or options.
	 * @param {string} [errorMessage] - Custom error message if consumption fails.
	 * @returns {SourceNode<K> | null} The consumed node or null.
	 */
	consume<K extends LanguageNodeTypes>(expectedTypeOrOptions?: K | K[] | {
		type?: K | K[];
		message?: string;
		validate?: (n: SourceNode<LanguageNodeTypes>) => boolean;
	}, errorMessage?: string): SourceNode<K> | null;
	/**
	 * Checks if a node is a descendant of another node.
	 * @param {SourceNode<any> | null} parent - Potential parent node.
	 * @param {SourceNode<any>} node - Target node to check.
	 * @returns {boolean} True if descendant, false otherwise.
	 */
	isDescendant(parent: SourceNode<any> | null, node: SourceNode<any>): boolean;
	/**
	 * Recursively walks the AST starting from a node and executes a callback.
	 * @param {SourceNode<any>} node - Start node.
	 * @param {function(SourceNode<any>): void} callback - The callback to execute for each node.
	 */
	walk(node: SourceNode<any>, callback: (n: SourceNode<any>) => void): void;
	/**
	 * Finds the next logical node after a specific index.
	 * @param {SourceNode<LanguageNodeTypes> | null} root - The search root.
	 * @param {number} index - The start index.
	 * @returns {SourceNode<LanguageNodeTypes> | null} The next node or null.
	 */
	findNextNodeAfter(root: SourceNode<LanguageNodeTypes> | null, index: number): SourceNode<LanguageNodeTypes> | null;
	/**
	 * Finds the nearest enclosing scope for the current macro.
	 * @returns {SourceNode<LanguageNodeTypes> | null} The scope node or null.
	 * @throws {Error} If not implemented in the base class.
	 */
	findScope(): SourceNode<LanguageNodeTypes> | null;
	/**
	 * Finds the nearest enclosing node of a given type.
	 * @param {SourceNode<any>} node - Start node.
	 * @param {K | K[]} types - Target node type(s).
	 * @returns {SourceNode<K> | null} The enclosing node or null.
	 */
	findEnclosing<K extends LanguageNodeTypes>(node: SourceNode<any>, types: K | K[]): SourceNode<K> | null;
	/**
	 * Creates a unique identifier with the given prefix.
	 * @param {string} [prefix='v'] - The prefix to use.
	 * @returns {string} The unique identifier.
	 */
	createUniqueIdentifier(prefix?: string): string;
	/**
	 * Throws an UPP error and associates it with a node.
	 * @param {SourceNode<any> | string} node - The node associated with the error or the message.
	 * @param {string} [message] - The error message.
	 * @returns {never}
	 */
	error(node: SourceNode<any> | string, message?: string): never;
}
export class FunctionSignature {
	returnType: string;
	name: string;
	params: string;
	node: SourceNode<CNodeTypes>;
	nameNode?: SourceNode<CNodeTypes> | null;
	bodyNode?: SourceNode<CNodeTypes> | null;
	constructor(returnType: string, name: string, params: string, node: SourceNode<CNodeTypes>, nameNode?: SourceNode<CNodeTypes> | null, bodyNode?: SourceNode<CNodeTypes> | null);
}
export type CNodeTypes = "translation_unit" | "preproc_include" | "preproc_def" | "preproc_function_def" | "preproc_params" | "preproc_call" | "preproc_if" | "preproc_ifdef" | "preproc_else" | "preproc_arg" | "function_definition" | "declaration" | "type_definition" | "struct_specifier" | "union_specifier" | "enum_specifier" | "enum_specifier_contents" | "enumerator" | "parameter_list" | "parameter_declaration" | "attributable_declarator" | "init_declarator" | "pointer_declarator" | "array_declarator" | "function_declarator" | "parenthesized_declarator" | "identifier" | "field_identifier" | "type_identifier" | "statement_identifier" | "primitive_type" | "sized_type_specifier" | "type_qualifier" | "storage_class_specifier" | "compound_statement" | "expression_statement" | "if_statement" | "while_statement" | "do_statement" | "for_statement" | "return_statement" | "break_statement" | "continue_statement" | "goto_statement" | "switch_statement" | "case_statement" | "labeled_statement" | "field_declaration_list" | "field_declaration" | "assignment_expression" | "binary_expression" | "unary_expression" | "update_expression" | "cast_expression" | "pointer_expression" | "sizeof_expression" | "subscript_expression" | "call_expression" | "argument_list" | "field_expression" | "compound_literal_expression" | "parenthesized_expression" | "comma_expression" | "conditional_expression" | "string_literal" | "number_literal" | "char_literal" | "null" | "true" | "false" | "comment";
/**
 * C-specific helper class.
 * @class
 * @extends UppHelpersBase
 */
export class UppHelpersC extends UppHelpersBase<CNodeTypes> {
	constructor(root: SourceNode<CNodeTypes>, registry: Registry, parentHelpers?: UppHelpersBase<any> | null);
	/**
	 * Finds the nearest enclosing C scope (compound_statement or translation_unit).
	 * @returns {SourceNode<CNodeTypes> | null} The scope node or null.
	 */
	findScope(): SourceNode<CNodeTypes> | null;
	/**
	 * Hoists content to the top of the file, skipping comments.
	 * @param {string} content - The content to hoist.
	 * @param {number} [_hoistIndex=0] - The index to hoist to.
	 */
	hoist(content: string, _hoistIndex?: number): void;
	/**
	 * extracts the C type string from a definition node.
	 * @param {SourceNode<CNodeTypes> | string | null} node - The identifier node or name.
	 * @param {{ resolve?: boolean }} [options] - Options for type resolution.
	 * @returns {string} The C type string (e.g. "char *").
	 */
	getType(node: SourceNode<CNodeTypes> | string | null, options?: {
		resolve?: boolean;
	}, _visited?: Set<string>): string;
	/**
	 * Returns the number of array dimensions wrapping an identifier.
	 * @param {SourceNode<CNodeTypes>} defNode - The definition node.
	 * @returns {number} Array depth.
	 */
	getArrayDepth(defNode: SourceNode<CNodeTypes>): number;
	/**
	 * Determines the lexical scope node for a given identifier.
	 * @param {SourceNode<any>} node - The identifier node.
	 * @returns {SourceNode<CNodeTypes>|null} The scope node.
	 */
	getEnclosingScope(node: SourceNode<any>): SourceNode<CNodeTypes> | null;
	/**
	 * Extracts function signature details including return type, name, parameters, and body.
	 * @param {SourceNode<CNodeTypes>} fnNode - The function_definition node.
	 * @returns {FunctionSignature} Signature details.
	 */
	getFunctionSignature(fnNode: SourceNode<CNodeTypes>): FunctionSignature;
	/**
	 * Finds the definition for a node or name, returning null if not found.
	 * @param {SourceNode<any>|string} target - The identifier node, a container node, or a scoping node (if name is provided).
	 * @param {string | { variable?: boolean, tag?: boolean } | null} [nameOrOptions] - The name to find or options object.
	 * @param {{ variable?: boolean, tag?: boolean }} [options] - Resolution options.
	 * @returns {SourceNode<CNodeTypes>|null} The declaration/definition node or null.
	 */
	findDefinitionOrNull(target: SourceNode<any> | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode<CNodeTypes> | null;
	/**
	 * Finds the definition for a node or name, throwing an error if not found.
	 * @param {SourceNode<any>|string} target - The identifier node, a container node, or a scoping node (if name is provided).
	 * @param {string | { variable?: boolean, tag?: boolean } | null} [nameOrOptions] - The name to find or options object.
	 * @param {{ variable?: boolean, tag?: boolean }} [options] - Resolution options.
	 * @returns {SourceNode<CNodeTypes>} The declaration/definition node.
	 */
	findDefinition(target: SourceNode<any> | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode<CNodeTypes>;
	/**
	 * Finds references to a definition.
	 * @param {SourceNode<CNodeTypes>} node - The definition node.
	 * @returns {SourceNode<CNodeTypes>[]} The references.
	 */
	findReferences(node: SourceNode<CNodeTypes>): SourceNode<CNodeTypes>[];
	/**
	 * Checks if the currently being transformed node is the declaration node
	 * for the symbol we are tracking with withReferences.
	 * @returns {boolean} True if the current node is the declaration.
	 */
	isDeclaration(): boolean;
	/**
	 * Registers a rule to transform any identifier that resolves to a specific definition.
	 * This is robust against code rewrites as it doesn't depend on specific node instances.
	 * @param {SourceNode<CNodeTypes>} definitionNode - The definition node to track.
	 * @param {function(SourceNode<CNodeTypes>, UppHelpersC): string|null|undefined} callback - Transformation callback.
	 */
	withReferences(definitionNode: SourceNode<CNodeTypes>, callback: (n: SourceNode<CNodeTypes>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Replaces placeholders in an array of nodes/strings.
	 * @param {InterpolationValue[]} values The values to expand.
	 * @param {CNodeTypes} parentType The tree-sitter node type of the parent.
	 * @returns {InterpolationValue[]} The expanded list of nodes/text.
	 */
	getArrayExpansion(values: InterpolationValue[], _parentType: CNodeTypes): InterpolationValue[];
}



} // End namespace upp_types

declare var upp: upp_types.UppHelpersC & {
    registry: upp_types.Registry;
    path: any;
    invocation: upp_types.Invocation;
    code: any;
};

