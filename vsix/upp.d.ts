// Generated by scripts/generate_vscode_dts.js

declare namespace Parser {
    type Tree = any;
    type SyntaxNode = any;
}


declare namespace upp_types {

// Generated by dts-bundle-generator v9.5.1


export interface DiagnosticsConfig {
	suppress?: string[];
}
export class DiagnosticsManager {
	private suppressed;
	/**
	 * @param {DiagnosticsConfig} [config={}] - Configuration object with suppression list.
	 */
	constructor(config?: DiagnosticsConfig);
	/**
	 * Reports a warning if not suppressed.
	 * @param {string | number} code - The diagnostic code (e.g., UPP001).
	 * @param {string} message - The warning message.
	 * @param {string} filePath - File where warning occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code for context.
	 */
	reportWarning(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null): void;
	/**
	 * Reports an error and optionally exits.
	 * @param {string | number} code - The diagnostic code.
	 * @param {string} message - The error message.
	 * @param {string} filePath - File where error occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code.
	 * @param {boolean} [fatal=true] - Whether to exit the process.
	 */
	reportError(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null, fatal?: boolean): void;
	/**
	 * Helper to calculate line and column from character index.
	 * @param {string} source - Source code.
	 * @param {number} index - Character index.
	 * @returns {{line: number, col: number}} 1-indexed line and col.
	 */
	static getLineCol(source: string, index: number): {
		line: number;
		col: number;
	};
}
export interface CacheData {
	macros: Macro[];
	transformRules: TransformRule[];
	output: string;
	shouldMaterialize: boolean;
	isAuthoritative: boolean;
}
export class DependencyCache {
	private cache;
	constructor();
	/**
	 * Checks if a file is in the cache.
	 * @param {string} filePath - Absolute path.
	 * @returns {boolean}
	 */
	has(filePath: string): boolean;
	/**
	 * Gets data for a file.
	 * @param {string} filePath
	 * @returns {CacheData | undefined}
	 */
	get(filePath: string): CacheData | undefined;
	/**
	 * Sets data for a file.
	 * @param {string} filePath
	 * @param {CacheData} data
	 */
	set(filePath: string, data: CacheData): void;
}
export interface MaterializeOptions {
	isAuthoritative: boolean;
}
export interface PatternMatchableNode {
	type: string;
	text: string;
	childCount: number;
	child(index: number): PatternMatchableNode | null;
}
export interface Macro {
	name: string;
	params: string[];
	body: string;
	language: string;
	origin: string;
	startIndex: number;
}
export interface TransformRule<T extends string = string> {
	active: boolean;
	matcher: (node: SourceNode<T>, helpers: any) => boolean;
	callback: (node: SourceNode<T>, helpers: any) => SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined;
}
export interface Invocation {
	name: string;
	args: string[];
	startIndex: number;
	endIndex: number;
	line?: number;
	col?: number;
	invocationNode?: SourceNode<any>;
}
export interface RegistryConfig {
	onMaterialize?: (outputPath: string, content: string, options: MaterializeOptions) => void;
	filePath?: string;
	stdPath?: string;
	cache?: DependencyCache;
	diagnostics?: DiagnosticsManager;
	suppress?: string[];
	comments?: boolean;
}
export interface Marker<T extends string = string> {
	callback: (node: SourceNode<T>, helpers: any) => SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined;
	data?: unknown;
}
export interface RegistryContext {
	source: string;
	tree: SourceTree<any>;
	originPath: string;
	invocations: Invocation[];
	helpers: UppHelpersBase<any> | null;
}
export type TreeSitterLang = unknown;
export class Registry {
	config: RegistryConfig;
	parentRegistry: Registry | null;
	depth: number;
	filePath: string;
	diagnostics: DiagnosticsManager;
	language: TreeSitterLang;
	helpers: UppHelpersBase<any> | null;
	parentHelpers: UppHelpersBase<any> | null;
	parentTree: SourceTree<any> | null;
	materializedFiles: Set<string>;
	isAuthoritative: boolean;
	macros: Map<string, Macro>;
	parser: any;
	idCounter: number;
	stdPath: string | null;
	loadedDependencies: Map<string, string>;
	shouldMaterializeDependency: boolean;
	transformRules: TransformRule<any>[];
	ruleIdCounter: number;
	isExecutingDeferred: boolean;
	onMaterialize: ((outputPath: string, content: string, options: {
		isAuthoritative: boolean;
	}) => void) | null;
	mainContext: RegistryContext | null;
	UppHelpersC: typeof UppHelpersC;
	source?: string;
	tree?: SourceTree<any>;
	deferredMarkers?: Marker<any>[];
	activeTransformNode?: SourceNode<any> | null;
	originPath?: string;
	constructor(config?: RegistryConfig, parentRegistry?: Registry | null);
	registerMacro(name: string, params: string[], body: string, language?: string, origin?: string, startIndex?: number): void;
	getMacro(name: string): Macro | undefined;
	registerTransformRule(rule: TransformRule<any> | ((node: SourceNode<any>, helpers: any) => SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined)): void;
	loadDependency(file: string, originPath?: string, parentHelpers?: UppHelpersC | null): void;
	generateRuleId(): string;
	transform(source: string, originPath?: string, parentHelpers?: UppHelpersC | null): string;
	transformNode(node: SourceNode<any>, helpers: any, context: RegistryContext): void;
	executeDeferredMarkers(helpers: any): void;
	evaluateMacro(invocation: Invocation, source: string, helpers: any, filePath: string): SourceNode<any> | SourceNode<any>[] | SourceTree<any> | string | null | undefined;
	createMacroFunction(macro: Macro): Function;
	prepareSource(source: string, originPath: string): {
		cleanSource: string;
		invocations: Invocation[];
	};
	extractBody(source: string, startOffset: number): string;
	findInvocations(source: string, tree?: any | null): Invocation[];
	absorbInvocation(text: string, startIndex: number): {
		name: string;
		args: string[];
	} | null;
	isInsideInvocation(_start: number, _end: number): boolean;
}
export class SourceTree<NodeTypes extends string = string> {
	source: string;
	language: any;
	parser: any;
	tree: any;
	nodeCache: Map<number | string, SourceNode<NodeTypes>>;
	root: SourceNode<NodeTypes>;
	/**
	 * @param {string} source Initial source code text.
	 * @param {any} language Tree-sitter language object.
	 */
	constructor(source: string, language: any);
	/**
	 * Internal method to get or create a SourceNode wrapper for a Tree-sitter node.
	 * @param {SyntaxNode | null} tsNode The Tree-sitter node to wrap.
	 * @param {SourceNode | null} [parent] The parent SourceNode, if any.
	 * @param {string | null} [fieldName] The field name for this node in the parent.
	 * @returns {SourceNode|null}
	 */
	wrap<T extends NodeTypes>(tsNode: any | null, parent?: SourceNode<NodeTypes> | null, fieldName?: string | null): SourceNode<T> | null;
	/**
	 * Apply a specialized splice to the source string and update tracking for all active nodes.
	 * @param {number} start The start index of the edit.
	 * @param {number} end The end index of the edit.
	 * @param {string} newText The replacement text.
	 */
	edit(start: number, end: number, newText: string): void;
	/** @returns {number} */
	get startIndex(): number;
	/** @returns {number} */
	get endIndex(): number;
	/** @returns {string} */
	get type(): string;
	/** @returns {SourceNode<any>[]} */
	get children(): SourceNode<NodeTypes>[];
	/** @returns {string} */
	get text(): string;
	/** @param {string} val */
	set text(val: string);
	/**
	 * Creates a SourceNode from a code fragment.
	 * Tries to parse as valid code; if it fails, wraps in a dummy function to parse statements/expressions.
	 * @param {string | SourceNode | SourceTree} code The text fragment to parse.
	 * @param {any} language Tree-sitter language object.
	 * @returns {SourceNode}
	 */
	static fragment<NodeTypes extends string = string>(code: string | SourceNode<any> | SourceTree<any>, language: any): SourceNode<NodeTypes>;
	/**
	 * Serializes the tree to JSON, avoiding circular references.
	 * @returns {Object}
	 */
	toJSON(): any;
	/**
	 * Merges current tree's nodes into another target SourceTree.
	 * @param {SourceTree} targetTree The tree to merge into.
	 * @param {number} offset The offset to apply to all migrated nodes.
	 */
	mergeInto(targetTree: SourceTree<NodeTypes>, offset: number): void;
}
export class SourceNode<T extends string = string> {
	tree: SourceTree<any>;
	id: number | string;
	type: T;
	startIndex: number;
	endIndex: number;
	children: SourceNode<any>[];
	parent: SourceNode<any> | null;
	fieldName: string | null;
	markers: Marker[];
	data: Record<string, unknown>;
	_capturedText?: string;
	_snapshotSearchable?: string;
	/**
	 * @param {SourceTree<any>} tree The tree this node belongs to.
	 * @param {SyntaxNode} tsNode The Tree-sitter node to wrap.
	 * @param {SourceNode<any> | null} [parent] The parent SourceNode, if any.
	 * @param {string | null} [fieldName] The field name for this node in the parent.
	 */
	constructor(tree: SourceTree<any>, tsNode: any, parent?: SourceNode<any> | null, fieldName?: string | null);
	/** @returns {boolean} */
	get isNamed(): boolean;
	/** @returns {boolean} */
	get isValid(): boolean;
	/** @returns {SourceNode<any>|null} */
	get nextNamedSibling(): SourceNode<any> | null;
	/** @returns {SourceNode<any>|null} */
	get prevNamedSibling(): SourceNode<any> | null;
	/** @returns {number} */
	get namedChildCount(): number;
	/**
	 * @param {number} idx
	 * @returns {SourceNode<any>|null}
	 */
	namedChild(idx: number): SourceNode<any> | null;
	/** @returns {SourceNode<any>|null} */
	get firstNamedChild(): SourceNode<any> | null;
	toString(): string;
	/** @returns {string} */
	get text(): string;
	/**
	 * Returns the name to use for symbol resolution.
	 * Prioritizes _capturedText to allow resolution by original name after a rename.
	 * @returns {string}
	 */
	get searchableText(): string;
	/** @param {string} value */
	set text(value: string);
	/** @returns {number} */
	get childCount(): number;
	get named(): Record<string, SourceNode<any>>;
	/**
	 * @returns {Object}
	 */
	toJSON(): Object;
	/**
	 * @param {number} idx
	 * @returns {SourceNode<any>}
	 */
	child(idx: number): SourceNode<any>;
	/**
	 * Internal method called by SourceTree when a global edit happens.
	 * @param {number} editStart The start index of the edit.
	 * @param {number} editEnd The end index of the edit.
	 * @param {number} delta Offset change duration.
	 */
	handleEdit(editStart: number, editEnd: number, delta: number): void;
	/**
	 * Removes the node from the tree and returns the removed sub-tree.
	 * @returns {SourceTree<any>}
	 */
	remove(): SourceTree<any>;
	/**
	 * Recursively invalidates this node and its children,
	 * removing them from the tree cache.
	 * @private
	 */
	_invalidateRecursively(): void;
	/**
	 * Replaces this node with another node or text.
	 * @param {SourceNode<any>|SourceTree<any>|string|Array<SourceNode<any>|string>} newNodeContent The node or text to replace with.
	 * @returns {SourceNode<any> | SourceNode<any>[] | null}
	 */
	replaceWith(content: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any>): SourceNode<any> | SourceNode<any>[] | null;
	/**
	 * Inserts a node or text after this node.
	 * @param {SourceNode<any>|SourceTree<any>|string} newNode The node or text to insert.
	 * @returns {SourceNode<any>|SourceNode<any>[]}
	 */
	insertAfter(content: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>): SourceNode<any> | SourceNode<any>[];
	/**
	 * Inserts a node or text before this node.
	 * @param {SourceNode<any>|SourceTree<any>|string} newNode The node or text to insert.
	 * @returns {SourceNode<any>|SourceNode<any>[]}
	 */
	insertBefore(content: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>): SourceNode<any> | SourceNode<any>[];
	_attachNewNode(newNode: SourceNode<any> | SourceTree<any> | string | Array<SourceNode<any> | string>, insertionOffset: number): SourceNode<any> | SourceNode<any>[] | null;
	/**
	 * Finds nodes matching a predicate or type within this subtree.
	 * @param {K | function(SourceNode<any>):boolean} predicate Type name or filter function.
	 * @returns {SourceNode<K>[]}
	 */
	find<K extends string>(predicate: K | ((n: SourceNode<any>) => boolean)): SourceNode<K>[];
	/**
	 * Finds the smallest descendant that contains the given index range.
	 * @param {number} start
	 * @param {number} end
	 * @returns {SourceNode<any>}
	 */
	descendantForIndex(start: number, end: number): SourceNode<any>;
	childForFieldName(fieldName: string): SourceNode<any> | null;
	/**
	 * Finds a direct child by its field name.
	 * @param {string} fieldName
	 * @returns {SourceNode<any>|null}
	 */
	findChildByFieldName(fieldName: string): SourceNode<any> | null;
	/**
	 * Appends a node or text as a child of this node.
	 * Requires the node to already have children to use as anchors.
	 * @param {SourceNode<any>|SourceTree<any>|string} newNode The node or text to append.
	 * @returns {SourceNode<any> | SourceNode<any>[]}
	 */
	append(newNode: SourceNode<any> | SourceTree<any> | string): SourceNode<any> | SourceNode<any>[];
}
export class UppHelpersBase<LanguageNodeTypes extends string> {
	root: SourceNode<LanguageNodeTypes> | null;
	registry: Registry;
	_parentHelpers: UppHelpersBase<LanguageNodeTypes> | null;
	contextNode: SourceNode<LanguageNodeTypes> | null;
	invocation: Invocation | null;
	lastConsumedNode: SourceNode<LanguageNodeTypes> | null;
	isDeferred: boolean;
	currentInvocations: Invocation[];
	consumedIds: Set<number | string>;
	context: RegistryContext | null;
	parentTree: SourceNode<any> | null;
	stdPath: string | null;
	lastConsumedIndex?: number;
	parentRegistry?: {
		invocations: Invocation[];
		sourceCode: string;
		helpers: UppHelpersBase<LanguageNodeTypes>;
	};
	topLevelInvocation?: Invocation | null;
	get parentHelpers(): UppHelpersBase<LanguageNodeTypes> | null;
	set parentHelpers(v: UppHelpersBase<LanguageNodeTypes> | null);
	get isAuthoritative(): boolean;
	set isAuthoritative(v: boolean);
	constructor(root: SourceNode<LanguageNodeTypes> | null, registry: Registry, parentHelpers?: UppHelpersBase<LanguageNodeTypes> | null);
	code(strings: TemplateStringsArray, ...values: any[]): SourceNode<LanguageNodeTypes>;
	/**
	 * Determines how an array should be expanded based on its parent context.
	 * @param {any[]} values The values to expand.
	 * @param {string} parentType The tree-sitter node type of the parent.
	 * @returns {any[]} The expanded list of nodes/text.
	 */
	protected getArrayExpansion(values: any[], parentType: string): any[];
	atRoot(callback: (root: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	withScope(callback: (scope: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	withRoot(callback: (root: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	/**
	 * @deprecated Use code or withPattern instead.
	 */
	registerTransform(callback: (root: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	registerTransformRule(rule: any): void;
	replace(n: SourceNode<LanguageNodeTypes>, newContent: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any> | null): SourceNode<LanguageNodeTypes> | SourceNode<LanguageNodeTypes>[] | null;
	insertBefore(n: SourceNode<LanguageNodeTypes>, content: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any>): SourceNode<LanguageNodeTypes> | SourceNode<LanguageNodeTypes>[];
	insertAfter(n: SourceNode<LanguageNodeTypes>, content: string | SourceNode<any> | SourceNode<any>[] | SourceTree<any>): SourceNode<LanguageNodeTypes> | SourceNode<LanguageNodeTypes>[];
	findRoot(): SourceNode<LanguageNodeTypes> | null;
	withNode(node: SourceNode<LanguageNodeTypes> | null, callback: (target: SourceNode<LanguageNodeTypes>, helpers: UppHelpersBase<LanguageNodeTypes>) => any): string;
	wrapNode(node: SourceNode<any>): SourceNode<any>;
	/**
	 * Finds macro invocations in the tree.
	 * @param {string} macroName
	 * @param {SourceNode<LanguageNodeTypes>} [node]
	 * @returns {any[]}
	 */
	findInvocations(macroName: string, node?: SourceNode<LanguageNodeTypes> | null): Invocation[];
	loadDependency(file: string): void;
	/**
	 * Finds the next logical node after the macro invocation.
	 * @private
	 */
	_getNextNode(expectedTypes?: string[] | null): SourceNode<LanguageNodeTypes> | null;
	/**
	 * Retrieves the next node without removing it from the tree.
	 * @param {K|K[] | null} [types]
	 * @returns {SourceNode<K>|null}
	 */
	nextNode<K extends LanguageNodeTypes>(types?: K | K[] | null): SourceNode<K> | null;
	consume<K extends LanguageNodeTypes>(expectedTypeOrOptions?: K | K[] | {
		type?: K | K[];
		message?: string;
		validate?: (n: SourceNode<LanguageNodeTypes>) => boolean;
	}, errorMessage?: string): SourceNode<K> | null;
	isDescendant(parent: SourceNode<any> | null, node: SourceNode<any>): boolean;
	walk(node: SourceNode<any>, callback: (n: SourceNode<any>) => void): void;
	parent(node: SourceNode<any>): SourceNode<any> | null;
	childForFieldName(node: SourceNode<any> | null, fieldName: string): SourceNode<any> | null;
	findNextNodeAfter(root: SourceNode<LanguageNodeTypes> | null, index: number): SourceNode<LanguageNodeTypes> | null;
	findScope(): SourceNode<LanguageNodeTypes> | null;
	findEnclosing<K extends LanguageNodeTypes>(node: SourceNode<any>, types: K | K[]): SourceNode<K> | null;
	createUniqueIdentifier(prefix?: string): string;
	childCount(node: SourceNode<any> | null): number;
	child(node: SourceNode<any> | null, index: number): SourceNode<any> | null;
	error(node: SourceNode<any> | string, message?: string): never;
}
export interface ConstraintSpec {
	type: string;
	not: boolean;
}
export type ConstraintMap = Map<string, ConstraintSpec[]>;
export interface CaptureResult {
	node?: PatternMatchableNode;
	[key: string]: any;
}
export class PatternMatcher {
	private parseFn;
	private cache;
	private language;
	/**
	 * @param {function(string): Tree} parseFn - Function to parse a code fragment.
	 * @param {any} language - The language object.
	 */
	constructor(parseFn: (code: string) => any, language: any);
	/**
	 * Matches a target node against a pattern string.
	 * @param {PatternMatchableNode} targetNode - The node to match against.
	 * @param {string} patternStr - The code pattern (e.g., "int $x = 0;").
	 * @param {boolean} [deep=false] - Whether to search the subtree.
	 * @returns {CaptureResult | null} Captures object or null.
	 */
	match(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult | null;
	/**
	 * Matches all occurrences of a pattern.
	 * @returns {Array<CaptureResult>} Array of capture objects.
	 */
	matchAll(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult[];
	/**
	 * Prepares a pattern string for matching.
	 * @param {string} patternStr - The pattern string to prepare.
	 * @returns {{ patternRoot: SyntaxNode; constraints: ConstraintMap }} Object containing patternRoot and constraints.
	 */
	prepare(patternStr: string): {
		patternRoot: any;
		constraints: ConstraintMap;
	};
	/**
	 * Recursively searches for a match in the subtree.
	 */
	private findMatch;
	private findAllMatches;
	/**
	 * Compares two nodes structurally with wildcards.
	 * @param {PatternMatchableNode} target
	 * @param {SyntaxNode} pattern
	 * @param {CaptureResult} captures
	 * @param {ConstraintMap} constraints
	 * @returns {boolean}
	 */
	private structuralMatch;
	private getWildcard;
	private getChildren;
	/**
	 * Pre-processes pattern string to extract constraints.
	 * @param {string} patternStr
	 * @returns {{cleanPattern: string, constraints: ConstraintMap}}
	 */
	private preprocessPattern;
	/**
	 * Parses a raw wildcard identifier into name and types.
	 * @param {string} rawId - The identifier text after $.
	 * @returns {{name: string; types: ConstraintSpec[]}}
	 */
	private parseWildcard;
}
export type CNodeTypes = "translation_unit" | "function_definition" | "declaration" | "identifier" | "type_identifier" | "field_identifier" | "statement_identifier" | "preproc_def" | "preproc_include" | "preproc_ifdef" | "preproc_if" | "preproc_else" | "preproc_elif" | "preproc_endif" | "type_definition" | "compound_statement" | "pointer_declarator" | "array_declarator" | "parameter_declaration" | "field_declaration" | "struct_specifier" | "union_specifier" | "enum_specifier" | "primitive_type" | "parameter_list" | "argument_list" | "initializer_list" | "init_declarator" | "parenthesized_declarator" | "enumerator_list" | "field_declaration_list" | "expression_statement" | "if_statement" | "for_statement" | "while_statement" | "do_statement" | "return_statement" | "break_statement" | "continue_statement" | "labeled_statement" | "goto_statement" | "switch_statement" | "case_statement" | "default_statement" | "cast_expression" | "unary_expression" | "binary_expression" | "conditional_expression" | "assignment_expression" | "comma_expression" | "subscript_expression" | "call_expression" | "field_expression" | "parenthesized_expression" | "number_literal" | "string_literal" | "char_literal" | "abstract_pointer_declarator" | "type_descriptor" | "storage_class_specifier" | "type_qualifier" | "pointer_declarator" | "function_declarator" | "array_declarator" | "parenthesized_declarator" | "struct_specifier" | "union_specifier" | "enum_specifier" | "enumerator" | "field_declaration" | "parameter_declaration" | "translation_unit" | "attributed_statement" | (string & {});
/**
 * C-specific helper class.
 * @class
 * @extends UppHelpersBase
 */
export class UppHelpersC extends UppHelpersBase<CNodeTypes> {
	matcher: PatternMatcher;
	transformKey?: string;
	constructor(root: SourceNode<CNodeTypes>, registry: Registry, parentHelpers?: UppHelpersBase<any> | null);
	/**
	 * Matches a pattern against code.
	 * @param {SourceNode<any>} node - Target node.
	 * @param {string | string[]} src - Pattern source code.
	 * @param {function(any): any} [callback] - Callback with captures.
	 * @param {any} [options] - Match options.
	 * @returns {any} Result of callback or captures object (or null).
	 */
	match(node: SourceNode<any>, src: string | string[], callback?: (captures: Record<string, any>) => any, options?: {
		deep?: boolean;
	}): any;
	/**
	 * Matches all occurrences of a pattern.
	 * @param {SourceNode<any>} node - Target node.
	 * @param {string | string[]} src - Pattern source code.
	 * @param {function(any): any} [callback] - Optional callback.
	 * @param {any} [options] - Options.
	 * @returns {any[]} Matches.
	 */
	matchAll(node: SourceNode<any>, src: string | string[], callback?: (match: {
		node: SourceNode<CNodeTypes>;
		captures: Record<string, any>;
	}) => any, options?: {
		deep?: boolean;
	}): any[];
	/**
	 * Registers a transformation for nodes matching a pattern.
	 * @param {SourceNode<any>} node - Root node to search within.
	 * @param {string | string[]} src - Pattern.
	 * @param {function(Record<string, any>, SourceNode<CNodeTypes>, UppHelpersC): any} callback - Transformation logic.
	 * @param {any} [options] - Optional settings.
	 */
	withPatternAndCaptures(node: SourceNode<any>, src: string | string[], callback: (captures: Record<string, any>, target: SourceNode<CNodeTypes>, helpers: UppHelpersC) => any, options?: any): void;
	/**
	 * Replaces all matches of a pattern.
	 * @param {SourceNode<CNodeTypes>} node - Scope.
	 * @param {string} src - Pattern.
	 * @param {function(any): string | null | undefined} callback - Replacement callback.
	 * @param {any} [options] - Options.
	 */
	matchReplace(node: SourceNode<CNodeTypes>, src: string, callback: (match: {
		node: SourceNode<CNodeTypes>;
		captures: Record<string, SourceNode<CNodeTypes>>;
	}) => string | null | undefined, options?: {
		deep?: boolean;
	}): void;
	/**
	 * Hoists content to the top of the file, skipping comments.
	 * @param {string} content - The content to hoist.
	 * @param {number} [_hoistIndex=0] - The index to hoist to.
	 */
	hoist(content: string, _hoistIndex?: number): void;
	/**
	 * extracts the C type string from a definition node.
	 * @param {SourceNode<CNodeTypes> | string | null} node - The identifier node or name.
	 * @returns {string} The C type string (e.g. "char *").
	 */
	getType(node: SourceNode<CNodeTypes> | string | null): string;
	/**
	 * Returns the number of array dimensions wrapping an identifier.
	 * @param {SourceNode<CNodeTypes>} defNode - The definition node.
	 * @returns {number} Array depth.
	 */
	getArrayDepth(defNode: SourceNode<CNodeTypes>): number;
	/**
	 * Determines the lexical scope node for a given identifier.
	 * @param {SourceNode<any>} node - The identifier node.
	 * @returns {SourceNode<CNodeTypes>|null} The scope node.
	 */
	getEnclosingScope(node: SourceNode<any>): SourceNode<CNodeTypes> | null;
	/**
	 * Extracts function signature details.
	 * @param {SourceNode<CNodeTypes>} fnNode - The function_definition node.
	 * @returns {any} Signature details.
	 */
	getFunctionSignature(fnNode: SourceNode<CNodeTypes>): any;
	/**
	 * Finds the definition for a node or name.
	 * @param {SourceNode<any>|string} target - The identifier node, a container node with a single identifier, or a scoping node (if name is provided).
	 * @param {string|any} [nameOrOptions] - The name to find (if target is a scope) or options object.
	 * @param {any} [options] - Resolution options { variable: true, tag: true }.
	 * @returns {SourceNode<CNodeTypes>|null} The declaration/definition node.
	 */
	findDefinitionOrNull(target: SourceNode<any> | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode<CNodeTypes> | null;
	/**
	 * Finds the definition for a node or name.
	 * @param {SourceNode<any>|string} target - The identifier node, a container node with a single identifier, or a scoping node (if name is provided).
	 * @param {string|any} [nameOrOptions] - The name to find (if target is a scope) or options object.
	 * @param {any} [options] - Resolution options { variable: true, tag: true }.
	 * @returns {SourceNode<CNodeTypes>} The declaration/definition node.
	 */
	findDefinition(target: SourceNode<any> | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode<CNodeTypes>;
	/**
	 * Finds references to a definition.
	 * @param {SourceNode<CNodeTypes>} node - The definition node.
	 * @returns {SourceNode<CNodeTypes>[]} The references.
	 */
	findReferences(node: SourceNode<CNodeTypes>): SourceNode<CNodeTypes>[];
	/**
	 * Transforms references to a definition intelligently.
	 * @param {SourceNode<CNodeTypes>} definitionNode - The definition node.
	 * @param {function(SourceNode, UppHelpersC): string|null|undefined} callback - Transformation callback.
	 */
	withReferences(definitionNode: SourceNode<CNodeTypes>, callback: (n: SourceNode<CNodeTypes>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Finds and transforms a definition node intelligently.
	 * @param {SourceNode<any>|string} target - The node or name.
	 * @param {function(SourceNode, UppHelpersC): string|null|undefined} callback - Transformation callback.
	 */
	withDefinition(target: SourceNode<any> | string, callback: (n: SourceNode<CNodeTypes>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Transforms nodes matching a pattern intelligently.
	 * @param {CNodeTypes} nodeType - The node type to match.
	 * @param {function(SourceNode, UppHelpersC): boolean} matcher - Custom matcher function.
	 * @param {function(SourceNode, UppHelpersC): string|null|undefined} callback - Transformation callback.
	 */
	withPattern(nodeType: CNodeTypes, matcher: (node: SourceNode<CNodeTypes>, helpers: UppHelpersC) => boolean, callback: (node: SourceNode<CNodeTypes>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Transforms nodes matching a source fragment pattern.
	 * @param {SourceNode<any>} scope - The search scope.
	 * @param {string} pattern - The source fragment pattern.
	 * @param {function(any, UppHelpersC): (string|null|undefined)} callback - Transformation callback.
	 */
	withMatch(scope: SourceNode<any>, pattern: string, callback: (captures: Record<string, SourceNode<CNodeTypes>>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Determines how an array should be expanded based on its C/UPP parent context.
	 * @param {any[]} values The values to expand.
	 * @param {CNodeTypes} parentType The tree-sitter node type of the parent.
	 * @returns {any[]} The expanded list of nodes/text.
	 */
	protected getArrayExpansion(values: any[], parentType: CNodeTypes): any[];
}



} // End namespace upp_types

declare var upp: upp_types.UppHelpersC & {
    registry: upp_types.Registry;
    path: any;
    invocation: upp_types.Invocation;
};

