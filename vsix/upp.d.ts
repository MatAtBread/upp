// Generated by scripts/generate_vscode_dts.js

declare namespace Parser {
    type Tree = any;
    type SyntaxNode = any;
}


declare namespace upp_types {

// Generated by dts-bundle-generator v9.5.1


export interface DiagnosticsConfig {
	suppress?: string[];
}
export class DiagnosticsManager {
	private suppressed;
	/**
	 * @param {DiagnosticsConfig} [config={}] - Configuration object with suppression list.
	 */
	constructor(config?: DiagnosticsConfig);
	/**
	 * Reports a warning if not suppressed.
	 * @param {string | number} code - The diagnostic code (e.g., UPP001).
	 * @param {string} message - The warning message.
	 * @param {string} filePath - File where warning occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code for context.
	 */
	reportWarning(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null): void;
	/**
	 * Reports an error and optionally exits.
	 * @param {string | number} code - The diagnostic code.
	 * @param {string} message - The error message.
	 * @param {string} filePath - File where error occurred.
	 * @param {number} [line=0] - Line number (1-indexed).
	 * @param {number} [col=0] - Column number (1-indexed).
	 * @param {string | null} [sourceCode=null] - Optional source code.
	 * @param {boolean} [fatal=true] - Whether to exit the process.
	 */
	reportError(code: string | number, message: string, filePath: string, line?: number, col?: number, sourceCode?: string | null, fatal?: boolean): void;
	/**
	 * Helper to calculate line and column from character index.
	 * @param {string} source - Source code.
	 * @param {number} index - Character index.
	 * @returns {{line: number, col: number}} 1-indexed line and col.
	 */
	static getLineCol(source: string, index: number): {
		line: number;
		col: number;
	};
}
export interface CacheData {
	macros: Macro[];
	transformRules: TransformRule[];
	output: string;
	shouldMaterialize: boolean;
	isAuthoritative: boolean;
}
export class DependencyCache {
	private cache;
	constructor();
	/**
	 * Checks if a file is in the cache.
	 * @param {string} filePath - Absolute path.
	 * @returns {boolean}
	 */
	has(filePath: string): boolean;
	/**
	 * Gets data for a file.
	 * @param {string} filePath
	 * @returns {CacheData | undefined}
	 */
	get(filePath: string): CacheData | undefined;
	/**
	 * Sets data for a file.
	 * @param {string} filePath
	 * @param {CacheData} data
	 */
	set(filePath: string, data: CacheData): void;
}
export interface MaterializeOptions {
	isAuthoritative: boolean;
}
export interface PatternMatchableNode {
	type: string;
	text: string;
	childCount: number;
	child(index: number): PatternMatchableNode | null;
}
export interface Macro {
	name: string;
	params: string[];
	body: string;
	language: string;
	origin: string;
	startIndex: number;
}
export interface TransformRule {
	active: boolean;
	matcher: (node: SourceNode, helpers: UppHelpersC) => boolean;
	callback: (node: SourceNode, helpers: UppHelpersC) => SourceNode | SourceNode[] | SourceTree | string | null | undefined;
}
export interface Invocation {
	name: string;
	args: string[];
	startIndex: number;
	endIndex: number;
	line?: number;
	col?: number;
	invocationNode?: SourceNode;
}
export interface RegistryConfig {
	onMaterialize?: (outputPath: string, content: string, options: MaterializeOptions) => void;
	filePath?: string;
	stdPath?: string;
	cache?: DependencyCache;
	diagnostics?: DiagnosticsManager;
	suppress?: string[];
	comments?: boolean;
}
export interface Marker {
	callback: (node: SourceNode, helpers: UppHelpersC) => SourceNode | SourceNode[] | SourceTree | string | null | undefined;
	data?: unknown;
}
export interface RegistryContext {
	source: string;
	tree: SourceTree;
	originPath: string;
	invocations: Invocation[];
	helpers: UppHelpersC | null;
}
export type TreeSitterLang = unknown;
export class Registry {
	config: RegistryConfig;
	parentRegistry: Registry | null;
	depth: number;
	filePath: string;
	diagnostics: DiagnosticsManager;
	language: TreeSitterLang;
	helpers: UppHelpersC | null;
	parentHelpers: UppHelpersBase | null;
	parentTree: SourceTree | null;
	materializedFiles: Set<string>;
	isAuthoritative: boolean;
	macros: Map<string, Macro>;
	parser: any;
	idCounter: number;
	stdPath: string | null;
	loadedDependencies: Map<string, string>;
	shouldMaterializeDependency: boolean;
	transformRules: TransformRule[];
	ruleIdCounter: number;
	isExecutingDeferred: boolean;
	onMaterialize: ((outputPath: string, content: string, options: {
		isAuthoritative: boolean;
	}) => void) | null;
	mainContext: RegistryContext | null;
	UppHelpersC: typeof UppHelpersC;
	source?: string;
	tree?: SourceTree;
	deferredMarkers?: Marker[];
	activeTransformNode?: SourceNode | null;
	originPath?: string;
	constructor(config?: RegistryConfig, parentRegistry?: Registry | null);
	registerMacro(name: string, params: string[], body: string, language?: string, origin?: string, startIndex?: number): void;
	getMacro(name: string): Macro | undefined;
	registerTransformRule(rule: TransformRule | ((node: SourceNode, helpers: UppHelpersC) => SourceNode | SourceNode[] | SourceTree | string | null | undefined)): void;
	loadDependency(file: string, originPath?: string, parentHelpers?: UppHelpersC | null): void;
	generateRuleId(): string;
	transform(source: string, originPath?: string, parentHelpers?: UppHelpersC | null): string;
	transformNode(node: SourceNode, helpers: UppHelpersC, context: RegistryContext): void;
	executeDeferredMarkers(helpers: UppHelpersC): void;
	evaluateMacro(invocation: Invocation, source: string, helpers: UppHelpersC, filePath: string): SourceNode | SourceNode[] | SourceTree | string | null | undefined;
	createMacroFunction(macro: Macro): Function;
	prepareSource(source: string, originPath: string): {
		cleanSource: string;
		invocations: Invocation[];
	};
	extractBody(source: string, startOffset: number): string;
	findInvocations(source: string, tree?: any | null): Invocation[];
	absorbInvocation(text: string, startIndex: number): {
		name: string;
		args: string[];
	} | null;
	isInsideInvocation(_start: number, _end: number): boolean;
}
export class SourceTree {
	source: string;
	language: any;
	parser: any;
	tree: any;
	nodeCache: Map<number | string, SourceNode>;
	root: SourceNode;
	/**
	 * @param {string} source Initial source code text.
	 * @param {any} language Tree-sitter language object.
	 */
	constructor(source: string, language: any);
	/**
	 * Internal method to get or create a SourceNode wrapper for a Tree-sitter node.
	 * @param {SyntaxNode | null} tsNode The Tree-sitter node to wrap.
	 * @param {SourceNode | null} [parent] The parent SourceNode, if any.
	 * @param {string | null} [fieldName] The field name for this node in the parent.
	 * @returns {SourceNode|null}
	 */
	wrap(tsNode: any | null, parent?: SourceNode | null, fieldName?: string | null): SourceNode | null;
	/**
	 * Apply a specialized splice to the source string and update tracking for all active nodes.
	 * @param {number} start The start index of the edit.
	 * @param {number} end The end index of the edit.
	 * @param {string} newText The replacement text.
	 */
	edit(start: number, end: number, newText: string): void;
	/** @returns {number} */
	get startIndex(): number;
	/** @returns {number} */
	get endIndex(): number;
	/** @returns {string} */
	get type(): string;
	/** @returns {SourceNode[]} */
	get children(): SourceNode[];
	/** @returns {string} */
	get text(): string;
	/** @param {string} val */
	set text(val: string);
	/**
	 * Creates a SourceNode from a code fragment.
	 * Tries to parse as valid code; if it fails, wraps in a dummy function to parse statements/expressions.
	 * @param {string | SourceNode | SourceTree} code The text fragment to parse.
	 * @param {any} language Tree-sitter language object.
	 * @returns {SourceNode}
	 */
	static fragment(code: string | SourceNode | SourceTree, language: any): SourceNode;
	/**
	 * Serializes the tree to JSON, avoiding circular references.
	 * @returns {Object}
	 */
	toJSON(): any;
	/**
	 * Merges current tree's nodes into another target SourceTree.
	 * @param {SourceTree} targetTree The tree to merge into.
	 * @param {number} offset The offset to apply to all migrated nodes.
	 */
	mergeInto(targetTree: SourceTree, offset: number): void;
}
export class SourceNode {
	tree: SourceTree;
	id: number | string;
	type: string;
	startIndex: number;
	endIndex: number;
	children: SourceNode[];
	parent: SourceNode | null;
	fieldName: string | null;
	markers: Marker[];
	data: Record<string, unknown>;
	_capturedText?: string;
	_snapshotSearchable?: string;
	/**
	 * @param {SourceTree} tree The tree this node belongs to.
	 * @param {SyntaxNode} tsNode The Tree-sitter node to wrap.
	 */
	constructor(tree: SourceTree, tsNode: any);
	/** @returns {boolean} */
	get isNamed(): boolean;
	/** @returns {boolean} */
	get isValid(): boolean;
	/** @returns {SourceNode|null} */
	get nextNamedSibling(): SourceNode | null;
	/** @returns {SourceNode|null} */
	get prevNamedSibling(): SourceNode | null;
	/** @returns {number} */
	get namedChildCount(): number;
	/**
	 * @param {number} idx
	 * @returns {SourceNode|null}
	 */
	namedChild(idx: number): SourceNode | null;
	/** @returns {SourceNode|null} */
	get firstNamedChild(): SourceNode | null;
	toString(): string;
	/** @returns {string} */
	get text(): string;
	/**
	 * Returns the name to use for symbol resolution.
	 * Prioritizes _capturedText to allow resolution by original name after a rename.
	 * @returns {string}
	 */
	get searchableText(): string;
	/** @param {string} value */
	set text(value: string);
	/** @returns {number} */
	get childCount(): number;
	get named(): Record<string, SourceNode>;
	/**
	 * @returns {Object}
	 */
	toJSON(): Object;
	/**
	 * @param {number} idx
	 * @returns {SourceNode}
	 */
	child(idx: number): SourceNode;
	/**
	 * Internal method called by SourceTree when a global edit happens.
	 * @param {number} editStart The start index of the edit.
	 * @param {number} editEnd The end index of the edit.
	 * @param {number} delta Offset change duration.
	 */
	handleEdit(editStart: number, editEnd: number, delta: number): void;
	/**
	 * Removes the node from the tree and returns the removed sub-tree.
	 * @returns {SourceTree}
	 */
	remove(): SourceTree;
	/**
	 * Recursively invalidates this node and its children,
	 * removing them from the tree cache.
	 * @private
	 */
	_invalidateRecursively(): void;
	/**
	 * Replaces this node with another node or text.
	 * @param {SourceNode|SourceTree|string|Array<SourceNode|string>} newNodeContent The node or text to replace with.
	 * @returns {SourceNode | SourceNode[] | null}
	 */
	replaceWith(newNodeContent: SourceNode | SourceTree | string | Array<SourceNode | string>): SourceNode | SourceNode[] | null;
	/**
	 * Inserts a node or text after this node.
	 * @param {SourceNode|SourceTree|string} newNode The node or text to insert.
	 * @returns {SourceNode|SourceNode[]}
	 */
	insertAfter(newNode: SourceNode | SourceTree | string): SourceNode | SourceNode[];
	/**
	 * Inserts a node or text before this node.
	 * @param {SourceNode|SourceTree|string} newNode The node or text to insert.
	 * @returns {SourceNode|SourceNode[]}
	 */
	insertBefore(newNode: SourceNode | SourceTree | string): SourceNode | SourceNode[];
	_attachNewNode(newNode: SourceNode | SourceTree | string | Array<SourceNode | string>, insertionOffset: number): SourceNode | SourceNode[] | null;
	/**
	 * Finds nodes matching a predicate or type within this subtree.
	 * @param {string|function(SourceNode):boolean} predicate Type name or filter function.
	 * @returns {SourceNode[]}
	 */
	find(predicate: string | ((n: SourceNode) => boolean)): SourceNode[];
	/**
	 * Finds the smallest descendant that contains the given index range.
	 * @param {number} start
	 * @param {number} end
	 * @returns {SourceNode}
	 */
	descendantForIndex(start: number, end: number): SourceNode;
	childForFieldName(fieldName: string): SourceNode | null;
	/**
	 * Finds a direct child by its field name.
	 * @param {string} fieldName
	 * @returns {SourceNode|null}
	 */
	findChildByFieldName(fieldName: string): SourceNode | null;
	/**
	 * Appends a node or text as a child of this node.
	 * Requires the node to already have children to use as anchors.
	 * @param {SourceNode|SourceTree|string} newNode The node or text to append.
	 * @returns {SourceNode | SourceNode[]}
	 */
	append(newNode: SourceNode | SourceTree | string): SourceNode | SourceNode[];
}
export class UppHelpersBase {
	root: SourceNode | null;
	registry: Registry;
	_parentHelpers: UppHelpersBase | null;
	contextNode: SourceNode | null;
	invocation: Invocation | null;
	lastConsumedNode: SourceNode | null;
	isDeferred: boolean;
	currentInvocations: Invocation[];
	consumedIds: Set<number | string>;
	context: RegistryContext | null;
	parentTree: SourceNode | null;
	stdPath: string | null;
	lastConsumedIndex?: number;
	parentRegistry?: {
		invocations: Invocation[];
		sourceCode: string;
		helpers: UppHelpersBase;
	};
	topLevelInvocation?: Invocation | null;
	get parentHelpers(): UppHelpersBase | null;
	set parentHelpers(v: UppHelpersBase | null);
	get isAuthoritative(): boolean;
	set isAuthoritative(v: boolean);
	constructor(root: SourceNode | null, registry: Registry, parentHelpers?: UppHelpersBase | null);
	code(strings: TemplateStringsArray, ...values: any[]): SourceNode;
	/**
	 * Determines how an array should be expanded based on its parent context.
	 * @param {any[]} values The values to expand.
	 * @param {string} parentType The tree-sitter node type of the parent.
	 * @returns {any[]} The expanded list of nodes/text.
	 */
	protected getArrayExpansion(values: any[], parentType: string): any[];
	atRoot(callback: (root: SourceNode, helpers: UppHelpersBase) => any): string;
	withScope(callback: (scope: SourceNode, helpers: UppHelpersBase) => any): string;
	withRoot(callback: (root: SourceNode, helpers: UppHelpersBase) => any): string;
	/**
	 * @deprecated Use code or withPattern instead.
	 */
	registerTransform(callback: (root: SourceNode, helpers: UppHelpersBase) => any): string;
	registerTransformRule(rule: any): void;
	replace(n: SourceNode, newContent: string | SourceNode | SourceNode[] | SourceTree | null): SourceNode | SourceNode[] | null;
	insertBefore(n: SourceNode, content: string | SourceNode | SourceNode[] | SourceTree): SourceNode | SourceNode[];
	insertAfter(n: SourceNode, content: string | SourceNode | SourceNode[] | SourceTree): SourceNode | SourceNode[];
	findRoot(): SourceNode | null;
	withNode(node: SourceNode | null, callback: (target: SourceNode, helpers: UppHelpersBase) => any): string;
	wrapNode(node: SourceNode): SourceNode;
	/**
	 * Finds macro invocations in the tree.
	 * @param {string} macroName
	 * @param {SourceNode} [node]
	 * @returns {any[]}
	 */
	findInvocations(macroName: string, node?: SourceNode | null): Invocation[];
	loadDependency(file: string): void;
	/**
	 * Finds the next logical node after the macro invocation.
	 * @private
	 */
	_getNextNode(expectedTypes?: string[] | null): SourceNode | null;
	/**
	 * Retrieves the next node without removing it from the tree.
	 * @param {string|string[] | null} [types]
	 * @returns {SourceNode|null}
	 */
	nextNode(types?: string | string[] | null): SourceNode | null;
	consume(expectedTypeOrOptions?: string | string[] | {
		type?: string | string[];
		message?: string;
		validate?: (n: SourceNode) => boolean;
	}, errorMessage?: string): SourceNode | null;
	isDescendant(parent: SourceNode | null, node: SourceNode): boolean;
	walk(node: SourceNode, callback: (n: SourceNode) => void): void;
	parent(node: SourceNode): SourceNode | null;
	childForFieldName(node: SourceNode | null, fieldName: string): SourceNode | null;
	findNextNodeAfter(root: SourceNode | null, index: number): SourceNode | null;
	findScope(): SourceNode | null;
	findEnclosing(node: SourceNode, types: string | string[]): SourceNode | null;
	createUniqueIdentifier(prefix?: string): string;
	childCount(node: SourceNode | null): number;
	child(node: SourceNode | null, index: number): SourceNode | null;
	error(node: SourceNode | string, message?: string): never;
}
export interface ConstraintSpec {
	type: string;
	not: boolean;
}
export type ConstraintMap = Map<string, ConstraintSpec[]>;
export interface CaptureResult {
	node?: PatternMatchableNode;
	[key: string]: any;
}
export class PatternMatcher {
	private parseFn;
	private cache;
	private language;
	/**
	 * @param {function(string): Tree} parseFn - Function to parse a code fragment.
	 * @param {any} language - The language object.
	 */
	constructor(parseFn: (code: string) => any, language: any);
	/**
	 * Matches a target node against a pattern string.
	 * @param {PatternMatchableNode} targetNode - The node to match against.
	 * @param {string} patternStr - The code pattern (e.g., "int $x = 0;").
	 * @param {boolean} [deep=false] - Whether to search the subtree.
	 * @returns {CaptureResult | null} Captures object or null.
	 */
	match(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult | null;
	/**
	 * Matches all occurrences of a pattern.
	 * @returns {Array<CaptureResult>} Array of capture objects.
	 */
	matchAll(targetNode: PatternMatchableNode, patternStr: string, deep?: boolean): CaptureResult[];
	/**
	 * Prepares a pattern string for matching.
	 * @param {string} patternStr - The pattern string to prepare.
	 * @returns {{ patternRoot: SyntaxNode; constraints: ConstraintMap }} Object containing patternRoot and constraints.
	 */
	prepare(patternStr: string): {
		patternRoot: any;
		constraints: ConstraintMap;
	};
	/**
	 * Recursively searches for a match in the subtree.
	 */
	private findMatch;
	private findAllMatches;
	/**
	 * Compares two nodes structurally with wildcards.
	 * @param {PatternMatchableNode} target
	 * @param {SyntaxNode} pattern
	 * @param {CaptureResult} captures
	 * @param {ConstraintMap} constraints
	 * @returns {boolean}
	 */
	private structuralMatch;
	private getWildcard;
	private getChildren;
	/**
	 * Pre-processes pattern string to extract constraints.
	 * @param {string} patternStr
	 * @returns {{cleanPattern: string, constraints: ConstraintMap}}
	 */
	private preprocessPattern;
	/**
	 * Parses a raw wildcard identifier into name and types.
	 * @param {string} rawId - The identifier text after $.
	 * @returns {{name: string; types: ConstraintSpec[]}}
	 */
	private parseWildcard;
}
/**
 * C-specific helper class.
 * @class
 * @extends UppHelpersBase
 */
export class UppHelpersC extends UppHelpersBase {
	matcher: PatternMatcher;
	transformKey?: string;
	constructor(root: SourceNode, registry: Registry, parentHelpers?: UppHelpersBase | null);
	/**
	 * Matches a pattern against code.
	 * @param {SourceNode} node - Target node.
	 * @param {string | string[]} src - Pattern source code.
	 * @param {function(any): any} [callback] - Callback with captures.
	 * @param {any} [options] - Match options.
	 * @returns {any} Result of callback or captures object (or null).
	 */
	match(node: SourceNode, src: string | string[], callback?: (captures: Record<string, any>) => any, options?: {
		deep?: boolean;
	}): any;
	/**
	 * Matches all occurrences of a pattern.
	 * @param {SourceNode} node - Target node.
	 * @param {string | string[]} src - Pattern source code.
	 * @param {function(any): any} [callback] - Optional callback.
	 * @param {any} [options] - Options.
	 * @returns {any[]} Matches.
	 */
	matchAll(node: SourceNode, src: string | string[], callback?: (match: {
		node: SourceNode;
		captures: Record<string, any>;
	}) => any, options?: {
		deep?: boolean;
	}): any[];
	/**
	 * Replaces all matches of a pattern.
	 * @param {SourceNode} node - Scope.
	 * @param {string} src - Pattern.
	 * @param {function(any): string | null | undefined} callback - Replacement callback.
	 * @param {any} [options] - Options.
	 */
	matchReplace(node: SourceNode, src: string, callback: (match: {
		node: SourceNode;
		captures: Record<string, SourceNode>;
	}) => string | null | undefined, options?: {
		deep?: boolean;
	}): void;
	/**
	 * Hoists content to the top of the file, skipping comments.
	 * @param {string} content - The content to hoist.
	 * @param {number} [_hoistIndex=0] - The index to hoist to.
	 */
	hoist(content: string, _hoistIndex?: number): void;
	/**
	 * extracts the C type string from a definition node.
	 * @param {SourceNode} node - The definition identifier node.
	 * @returns {string} The C type string (e.g. "char *").
	 */
	getType(node: SourceNode): string;
	/**
	 * Returns the number of array dimensions wrapping an identifier.
	 * @param {SourceNode} defNode - The definition node.
	 * @returns {number} Array depth.
	 */
	getArrayDepth(defNode: SourceNode): number;
	/**
	 * Determines the lexical scope node for a given identifier.
	 * @param {SourceNode} node - The identifier node.
	 * @returns {SourceNode|null} The scope node.
	 */
	getEnclosingScope(node: SourceNode): SourceNode | null;
	/**
	 * Extracts function signature details.
	 * @param {SourceNode} fnNode - The function_definition node.
	 * @returns {any} Signature details.
	 */
	getFunctionSignature(fnNode: SourceNode): any;
	/**
	 * Finds the definition for a node or name.
	 * @param {SourceNode|string} target - The identifier node, a container node with a single identifier, or a scoping node (if name is provided).
	 * @param {string|any} [nameOrOptions] - The name to find (if target is a scope) or options object.
	 * @param {any} [options] - Resolution options { variable: true, tag: true }.
	 * @returns {SourceNode|null} The declaration/definition node.
	 */
	findDefinitionOrNull(target: SourceNode | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode | null;
	/**
	 * Finds the definition for a node or name.
	 * @param {SourceNode|string} target - The identifier node, a container node with a single identifier, or a scoping node (if name is provided).
	 * @param {string|any} [nameOrOptions] - The name to find (if target is a scope) or options object.
	 * @param {any} [options] - Resolution options { variable: true, tag: true }.
	 * @returns {SourceNode} The declaration/definition node.
	 */
	findDefinition(target: SourceNode | string, nameOrOptions?: string | {
		variable?: boolean;
		tag?: boolean;
	} | null, options?: {
		variable?: boolean;
		tag?: boolean;
	}): SourceNode;
	/**
	 * Finds references to a definition.
	 * @param {SourceNode} node - The definition node.
	 * @returns {SourceNode[]} The references.
	 */
	findReferences(node: SourceNode): SourceNode[];
	/**
	 * Transforms references to a definition intelligently:
	 * - For references below the current node: applies callback immediately
	 * - For references above the current node: creates deferred markers for later transformation
	 * - Registers a transformation rule to handle dynamically generated references
	 *
	 * @param {SourceNode} definitionNode - The definition node to find references for
	 * @param {function(SourceNode): string|null|undefined} callback - Transformation callback.
	 *        Return: string (replace), null/"" (delete), undefined (no change)
	 * @returns {string} Marker for deferred transformations (empty if all references were below)
	 */
	withReferences(definitionNode: SourceNode, callback: (n: SourceNode) => string | null | undefined): string;
	/**
	 * Finds and transforms a definition node intelligently.
	 * Similar to withReferences but operates on the definition itself.
	 *
	 * @param {SourceNode|string} target - The node or name to find definition for
	 * @param {function(SourceNode): string|null|undefined} callback - Transformation callback.
	 *        Return: string (replace), null/"" (delete), undefined (no change)
	 * @returns {string} Marker for deferred transformations (empty if definition was below)
	 */
	withDefinition(target: SourceNode | string, callback: (n: SourceNode, helpers: UppHelpersC) => string | null | undefined): string;
	/**
	 * Transforms nodes matching a pattern intelligently.
	 * Registers a transformation rule for re-evaluation on generated code.
	 *
	 * @param {string} nodeType - The node type to match (e.g., 'call_expression')
	 * @param {function(SourceNode, UppHelpersC): boolean} matcher - Custom matcher function
	 * @param {function(SourceNode, UppHelpersC): string|null|undefined} callback - Transformation callback
	 * @returns {string} Marker for deferred transformations
	 */
	withPattern(nodeType: string, matcher: (node: SourceNode, helpers: UppHelpersC) => boolean, callback: (node: SourceNode, helpers: UppHelpersC) => string | null | undefined): string;
	/**
	 * Transforms nodes matching a source fragment pattern.
	 * @param {SourceNode} scope - The search scope.
	 * @param {string} pattern - The source fragment pattern.
	 * @param {function(any, UppHelpersC): (string|null|undefined)} callback - Transformation callback (receives captures).
	 */
	withMatch(scope: SourceNode, pattern: string, callback: (captures: Record<string, SourceNode>, helpers: UppHelpersC) => string | null | undefined): void;
	/**
	 * Determines how an array should be expanded based on its C/UPP parent context.
	 * @param {any[]} values The values to expand.
	 * @param {string} parentType The tree-sitter node type of the parent.
	 * @returns {any[]} The expanded list of nodes/text.
	 */
	protected getArrayExpansion(values: any[], parentType: string): any[];
}



} // End namespace upp_types

declare var upp: upp_types.UppHelpersC & {
    registry: upp_types.Registry;
    path: any;
    invocation: upp_types.Invocation;
};

